<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPTV Editor Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #4a90e2;
            --primary-hover: #357abd;
            --primary-light: #eaf3fe;
            --danger: #dc3545;
            --danger-hover: #bb2d3b;
            --danger-light: #f8d7da;
            --success: #28a745; /* Updated green */
            --success-hover: #218838;
            --success-light: #dff0d8; /* Softer green */
            --info: #0dcaf0;
            --info-hover: #31d2f2;
            --info-light: #cff4fc;
            --warning: #ffc107;
            --warning-hover: #ffca2c;
            --dark: #333;
            --text-dark: #2f3337;
            --text-light: #7a828b;
            --light: #f7f8fa;
            --light-alt: #ffffff;
            --border-color: #e1e4e8;
            --sidebar-bg: #ffffff;
            --header-bg: #004a99; /* Slightly different blue */
            --header-text: #ffffff;
            --sidebar-collapsed-width: 65px;
            --sidebar-expanded-width: 240px;
            --content-padding: 20px;
            --border-radius: 6px;
            --shadow-soft: 0 1px 3px rgba(0,0,0,0.06);
            --shadow-medium: 0 4px 10px rgba(0,0,0,0.08);
            --transition-speed: 0.3s;
            --selected-bg: #e7f3ff;
            --accent-purple: #6f42c1;
            --accent-pink: #d63384;
            --accent-orange: #fd7e14;
            --accent-teal: #20c997;
            --accent-indigo: #6610f2;
        }

        *, *::before, *::after { box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--light);
            color: var(--text-dark);
            font-size: 14px;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .dashboard-layout {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .sidebar {
            width: var(--sidebar-collapsed-width);
            background: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: var(--content-padding) 0;
            flex-shrink: 0;
            z-index: 1020;
            box-shadow: 2px 0 10px rgba(0,0,0,0.07);
            overflow-x: hidden;
            overflow-y: auto;
            transition: width var(--transition-speed) ease;
        }

        .sidebar-header {
            width: 100%;
            text-align: center;
            margin-bottom: 20px;
            padding: 0 5px;
        }

        #sidebar-toggle {
            margin-bottom: 15px;
             width: 40px; height: 40px;
             font-size: 1.1em;
        }


        .sidebar-logo {
            color: var(--primary);
            font-size: 1.8em;
             margin-bottom: 30px;
             display: block;
        }
        .sidebar-logo-text {
            font-size: 1.2rem; font-weight: 600; color: var(--text-dark); display: none; white-space: nowrap;
            padding: 0 15px;
            text-align: left;
            margin-bottom: 25px;
            opacity: 0;
             transition: opacity 0.2s linear;
        }


        .sidebar-nav ul { list-style: none; padding: 0; margin: 0; width: 100%; text-align: center; }
        .sidebar-nav li { margin-bottom: 5px; }
        .sidebar-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            margin: 0 auto 10px auto;
            border: none;
            background-color: transparent;
            color: var(--text-light);
            border-radius: var(--border-radius);
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color var(--transition-speed), color var(--transition-speed), width var(--transition-speed), justify-content var(--transition-speed), padding var(--transition-speed);
            position: relative;
            overflow: hidden;
            padding: 0 10px;
        }
        .sidebar-btn i {
            line-height: 1;
            flex-shrink: 0;
             width: 20px;
             text-align: center;
             margin-right: 0;
             transition: margin-right var(--transition-speed) ease, color var(--transition-speed) ease;
        }
         .sidebar-btn-text {
             white-space: nowrap;
             opacity: 0;
             margin-left: 10px;
             transition: opacity 0.2s linear 0.1s; /* Delay opacity */
             font-size: 0.9rem;
             font-weight: 500;
             display: none; /* Initially hidden */
         }

        .sidebar-btn:hover, .sidebar-btn.active {
            background-color: var(--primary-light);
            /* color: var(--primary); Keep original icon color */
        }
        .sidebar-btn:hover i, .sidebar-btn.active i {
             /* Slightly enhance icon on hover/active */
            filter: brightness(0.9);
        }
        .sidebar-btn.danger:hover {
             background-color: var(--danger-light);
        }
        .sidebar-btn.danger i { color: var(--danger); } /* Keep icon red */


        /* Icon Colors */
        #open-btn i { color: var(--primary); }
        #save-btn i { color: var(--success); }
        #new-list-btn i { color: var(--accent-teal); }
        #compare-btn i { color: var(--accent-orange); }
        #manage-groups-btn i { color: var(--accent-purple); }
        #validate-urls-btn i { color: var(--accent-indigo); }
        #find-duplicates-btn i { color: var(--warning); }
        #toggle-favorites-btn i { color: var(--accent-pink); }
        /* Clear stays danger */


        .sidebar-footer { margin-top: auto; width: 100%; text-align: center; }

        body.sidebar-expanded .sidebar { width: var(--sidebar-expanded-width); }
         body.sidebar-expanded .sidebar-logo { display: none; }
         body.sidebar-expanded .sidebar-logo-text { display: block; opacity: 1; }
         body.sidebar-expanded .sidebar-btn { width: calc(100% - 20px); justify-content: flex-start; margin-left: 10px; margin-right: 10px; }
         body.sidebar-expanded .sidebar-btn i { margin-right: 0; }
         body.sidebar-expanded .sidebar-btn-text { display: inline; opacity: 1; }



        .main-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            /*margin-left: var(--sidebar-collapsed-width); REMOVED - managed by grid now */
        }

        .main-header {
            background-color: var(--header-bg);
            color: var(--header-text);
            padding: 0 var(--content-padding);
            display: flex;
            align-items: center;
            height: 60px;
            flex-shrink: 0;
            box-shadow: var(--shadow-soft);
            z-index: 1010;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }
        .main-header .search-container {
            flex-grow: 1;
            margin: 0 20px; /* Center it a bit more */
            max-width: 350px;
        }
         .main-header .search-container input[type="search"] {
            width: 100%;
            height: 36px;
            padding: 0 15px 0 35px;
            border-radius: 18px;
            border: none;
            background-color: rgba(255,255,255,0.9);
            color: var(--text-dark);
            font-size: 0.9rem;
         }
        .main-header .search-container i {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-light);
            font-size: 0.9em;
        }
         .main-header .search-wrapper { position: relative; }


         .main-header .header-logo {
            font-weight: 700;
            font-size: 1.5rem;
             margin-right: auto;
            text-transform: uppercase;
            letter-spacing: 1px;
         }
          .main-header .header-actions {
             margin-left: 20px;
            display: flex;
            align-items: center;
             gap: 10px;
          }
          .header-btn {
             background-color: rgba(255, 255, 255, 0.15);
             color: var(--header-text);
             border: none;
             padding: 6px 12px;
             font-size: 0.8rem;
             border-radius: var(--border-radius);
             cursor: pointer;
              height: auto;
             transition: background-color 0.2s;
          }
          .header-btn:hover { background-color: rgba(255, 255, 255, 0.3); }


        .content-wrapper {
            flex-grow: 1;
            display: flex;
            overflow: hidden;
            background-color: var(--light-alt);
        }

        .list-panel {
            width: 100%;
            display: flex;
            flex-direction: column;
            /* border-right: 1px solid var(--border-color);  Border now applied conditionally by JS/Body Class */
            border-right: none;
            overflow: hidden;
            transition: width var(--transition-speed) ease;
        }
         body.editor-visible .list-panel {
             width: 60%;
             border-right: 1px solid var(--border-color);
         }

        .list-toolbar {
            padding: 15px var(--content-padding);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            flex-shrink: 0;
             background-color: var(--light-alt);
        }
        #file-name-display {
             font-size: 0.9rem;
             font-weight: 500;
             background-color: var(--light);
             padding: 4px 10px;
             border-radius: var(--border-radius);
             border: 1px solid var(--border-color);
             color: var(--text-light);
             margin-right: auto;
        }
        #file-name-display.loaded {
           color: var(--text-dark);
           border-color: var(--primary);
           background-color: var(--primary-light);
         }
         .list-toolbar .btn { height: 32px; padding: 0 12px; font-size: 0.8rem;}
         .list-toolbar #group-filter { height: 32px; font-size: 0.8rem; padding: 0 8px; min-width: 150px; }

        .table-container {
            flex-grow: 1;
            overflow-y: auto;
            border: none;
             box-shadow: none;
             border-radius: 0;
             margin-bottom: 0;
             background: transparent;
        }

        table { min-width: 550px; border-collapse: separate; border-spacing: 0; width: 100%;}
        th, td { padding: 10px 12px; white-space: nowrap; font-size: 0.85rem; vertical-align: middle; } /* Increased padding */
         td { border-bottom: 1px solid var(--border-color); }
        th { background-color: #f8f9fa; font-weight: 600; position: sticky; top: 0; z-index: 10; border-bottom: 1px solid #d1d5db; cursor: default;}
         th.sortable { cursor: pointer; }

         .handle-cell { width: 40px; text-align: center; }
         .logo-cell { width: 50px; text-align: center; }
         .name-cell { min-width: 180px; white-space: normal; font-weight: 500;}
         .url-cell { max-width: 250px; overflow: hidden; text-overflow: ellipsis; color: var(--text-light); font-size: 0.8rem;}
         .epg-cell { width: 120px; overflow: hidden; text-overflow: ellipsis; }
         .ch-num-cell { width: 60px; text-align: right; color: var(--text-light); }

         .drag-handle { cursor: move; color: var(--grey-dark); padding: 0 8px 0 0; opacity: 0.6; }
         tr:hover .drag-handle { opacity: 1;}
         .logo-preview { max-width: 32px; max-height: 20px; vertical-align: middle; object-fit: contain; background-color: var(--light); border-radius: 3px; }


         tr.channel-row { cursor: pointer; transition: background-color var(--transition-speed); }
         tr.channel-row:hover { background-color: #f0f5ff; }
         tr.channel-row.selected-row { background-color: var(--selected-bg) !important; }
         tr.channel-row.selected-row td { border-bottom-color: var(--primary); }

         .group-header-row { background-color: #f3f4f6; font-weight: 600; cursor: pointer; transition: background-color var(--transition-speed); user-select: none;}
         .group-header-row:hover { background-color: #e5e7eb; }
         .group-header-row td { padding: 8px 12px; border-bottom: 1px solid #d1d5db; }
         .group-toggle-icon { margin-right: 8px; width: 14px; text-align: center; display: inline-block; transition: transform var(--transition-speed); font-size: 0.8em;}
         .group-header-row.collapsed .group-toggle-icon { transform: rotate(-90deg); }
         .channel-row.hidden { display: none; }
         .group-channel-count { font-size: 0.8em; color: var(--text-light); margin-left: 8px; font-weight: 400; }


        .editor-panel {
            width: 0;
            padding: 0;
            border-left: none;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: var(--light-alt);
            transition: width var(--transition-speed) ease, padding var(--transition-speed) ease, opacity var(--transition-speed) ease, border-left var(--transition-speed) ease;
            opacity: 0;
            flex-shrink: 0;
        }
        body.editor-visible .editor-panel {
            width: 40%;
            opacity: 1;
            overflow-y: auto;
             padding: var(--content-padding);
             border-left: 1px solid var(--border-color);
        }

         .editor-panel-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 20px;
             padding-bottom: 10px;
             border-bottom: 1px solid var(--border-color);
             flex-shrink: 0;
             background-color: var(--light-alt); /* Ensure header matches background */
         }
         .editor-panel-header h3 { margin: 0; font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; }
          .editor-panel-header i { color: var(--primary); margin-right: 8px; }
         .btn-close-editor { background:none; border: none; font-size: 1.5rem; color: var(--text-light); cursor: pointer; padding: 0 5px; opacity: 0.7; transition: opacity 0.2s; line-height: 1;}
         .btn-close-editor:hover { opacity: 1;}

        .editor-panel-content {
            flex-grow: 1;
        }

        .editor-panel .form-group { margin-bottom: 20px; } /* Increased spacing */
        .editor-panel label { display: block; font-weight: 500; margin-bottom: 8px; font-size: 0.85rem; color: var(--text-dark); }
        .editor-panel input[type="text"],
        .editor-panel input[type="url"],
        .editor-panel input[type="number"],
        .editor-panel textarea {
            width: 100%;
            height: 38px; /* Slightly taller */
            padding: 0 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 0.9rem;
             background-color: var(--light-alt);
             transition: border-color 0.2s, box-shadow 0.2s;
             line-height: 1.5;
        }
         .editor-panel textarea {
             height: auto;
             min-height: 76px; /* ~3 lines */
             padding: 8px 12px;
             resize: vertical;
        }

         .editor-panel input:focus, .editor-panel textarea:focus { border-color: var(--primary); outline: none; box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.15);}
         .editor-panel .input-group { display: flex; gap: 15px; }
         .editor-panel .input-group .form-group { flex: 1; margin-bottom: 0;}
         .editor-panel input[type="number"] { padding-left: 25px; }
         .editor-panel .ch-num-wrapper { position: relative; }
         .editor-panel .ch-num-wrapper::before {
             content: "#";
             position: absolute;
             left: 10px;
             top: 50%;
             transform: translateY(-50%);
             color: var(--text-light);
             font-size: 0.9rem;
             font-weight: 600;
         }

         .editor-logo-preview {
            max-width: 100px;
            max-height: 60px;
            object-fit: contain;
            margin-bottom: 10px;
            border: 1px dashed var(--border-color);
            padding: 5px;
             display: block;
             border-radius: var(--border-radius);
             background-color: #f8f9fa;
             min-height: 30px;
             text-align: center;
             line-height: 30px;
             color: var(--text-light);
        }
         .editor-logo-preview[src=''] { display: none; }


         .editor-group-actions { display: flex; align-items: center; gap: 8px; }
         .editor-group-actions input { flex-grow: 1; }
         .editor-group-actions .btn { flex-shrink: 0; height: 38px; font-size: 0.8rem; padding: 0 10px;} /* Match input height */

         .editor-panel .form-check-group { display: flex; gap: 15px; flex-wrap: wrap; margin-top: 8px; }
         .editor-panel .form-check { display: flex; align-items: center; gap: 6px; }
         .editor-panel .form-check input[type="checkbox"] { width: auto; height: auto; flex-shrink: 0;}
         .editor-panel .form-check label { margin-bottom: 0; font-weight: 400; font-size: 0.85rem;}

         .editor-panel h6 {
             font-weight: 600;
             margin: 25px 0 15px 0; /* More margin bottom */
             padding-top: 15px;
             border-top: 1px solid var(--border-color);
             font-size: 0.9rem;
             color: var(--primary);
         }
         #apply-headers-check-container { margin-top: 8px; }


        .editor-footer {
            margin-top: 25px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
            display: flex;
             flex-wrap: wrap;
            justify-content: space-between;
             gap: 10px;
            flex-shrink: 0;
        }
         .editor-footer .btn { height: 38px; font-size: 0.85rem; padding: 0 15px;} /* Match input height */
         .editor-footer .btn-delete { background-color: var(--danger); color: white;}
         .editor-footer .btn-delete:hover { background-color: var(--danger-hover);}
         .editor-footer .btn-save { background-color: var(--success); color: white;}
         .editor-footer .btn-save:hover { background-color: var(--success-hover);}
         .editor-footer .btn-move-top { background-color: #545b62; color: white; }
         .editor-footer .btn-move-top:hover { background-color: #41464b; }

         #editor-placeholder {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: var(--text-light);
             text-align: center;
             padding: 20px;
         }
         #editor-placeholder i { font-size: 3em; margin-bottom: 15px; opacity: 0.5;}
         #editor-placeholder p { font-size: 1rem; }


        .modal { display: none; position: fixed; z-index: 1050; left: 0; top: 0; width: 100%; height: 100%; overflow: hidden; background-color: rgba(40,40,40,0.7); /* Darker backdrop */ align-items: center; justify-content: center; backdrop-filter: blur(3px); }
        .modal-content { background-color: var(--light-alt); margin: auto; padding: 0; border: none; width: 90%; max-width: 550px; border-radius: var(--border-radius); box-shadow: var(--shadow-medium); position: relative; display: flex; flex-direction: column; max-height: 90vh; overflow: hidden; border: 1px solid var(--border-color); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 18px 25px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; background: linear-gradient(180deg, var(--light) 0%, #f9fafb 100%); border-top-left-radius: var(--border-radius); border-top-right-radius: var(--border-radius);}
        .modal-title { margin: 0; font-size: 1.2rem; font-weight: 600; }
        .modal-close { background: transparent; border: none; font-size: 1.3rem; width: 30px; height: 30px; line-height: 30px; text-align:center; cursor: pointer; color: var(--text-light); padding: 0; opacity: 0.7; transition: background-color 0.2s, color 0.2s; border-radius: 50%;}
        .modal-close:hover { opacity: 1; background-color: #e9ecef; color: var(--dark);}
        .modal-body { padding: 25px; overflow-y: auto; flex-grow: 1; background-color: var(--light-alt); }
        .modal-body label { display: block; margin-bottom: 8px; font-weight: 500; font-size: 0.85rem; }
        .modal-body input[type="text"], .modal-body input[type="url"], .modal-body textarea, .modal-body select { width: 100%; margin-bottom: 18px; }
         .modal-body hr { margin: 25px 0; border-color: #eee; }
         .modal-body h6 { font-weight: 600; margin-bottom: 10px; }
        .modal-footer { padding: 18px 25px; text-align: right; border-top: 1px solid var(--border-color); flex-shrink: 0; background-color: var(--light); border-bottom-left-radius: var(--border-radius); border-bottom-right-radius: var(--border-radius);}
        .modal-footer .btn { margin-left: 8px; }

         #compare-modal .modal-content { max-width: 950px; }
         #duplicates-modal .modal-content { max-width: 850px; }
         #confirm-modal .modal-content { max-width: 450px; }

        #toast-container { position: fixed; bottom: 20px; right: 20px; z-index: 1100; }
        .toast { background-color: rgba(40, 44, 52, 0.95); color: var(--white); padding: 12px 20px; margin-bottom: 10px; border-radius: var(--border-radius); box-shadow: var(--shadow-medium); opacity: 0; transition: opacity 0.5s, transform 0.5s; transform: translateX(100%); display: flex; align-items: center; gap: 10px; min-width: 280px; font-size: 0.9rem; backdrop-filter: blur(2px);}
        .toast.show { opacity: 1; transform: translateX(0); }
        .toast.success { background-color: rgba(25, 135, 84, 0.9); border-left: 4px solid #157347; }
        .toast.error { background-color: rgba(220, 53, 69, 0.9); border-left: 4px solid #bb2d3b;}
        .toast.info { background-color: rgba(13, 202, 240, 0.9); color: var(--text-dark); border-left: 4px solid #0a80a0; }
        .toast.warning { background-color: rgba(255, 193, 7, 0.9); color: var(--text-dark); border-left: 4px solid #c79100; }


        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.8); z-index: 1070; display: none; align-items: center; justify-content: center; flex-direction: column; gap: 15px; }
        .spinner { border: 6px solid #e9ecef; border-top: 6px solid var(--primary); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        #loading-message { font-weight: 500; color: var(--text-dark); }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .hidden { display: none !important; }

         .compare-diff { background-color: rgba(255, 193, 7, 0.3); padding: 1px 4px; border-radius: 3px; font-weight: 600;}
         #compare-modal .modal-body { background-color: var(--light); }
        #compare-modal .modal-body > p { margin-bottom: 20px; font-weight: 500;}
        #compare-modal h6 { font-weight: 600; margin-bottom: 10px; border-bottom: 1px solid var(--border-color); padding-bottom: 5px;}
        #compare-modal ul { background-color: var(--white); list-style: none; padding: 0; font-size: 0.85em; max-height: 45vh; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; margin: 0; border-radius: var(--border-radius); }
        #compare-modal ul li { border-bottom: 1px solid #eee; padding: 5px 8px; }
        #compare-modal ul li:last-child { border-bottom: none; }
        .compare-list-a-name-dynamic, .compare-list-b-name-dynamic { font-weight: bold; }
        #copy-missing-to-a-btn { margin-top: 10px; }
        .duplicate-set { border: 1px solid var(--border-color); border-radius: var(--border-radius); margin-bottom: 15px; padding: 15px 20px; background-color: var(--light-alt); position: relative; box-shadow: var(--shadow-soft); }
        .duplicate-set p { margin-bottom: 8px; font-size: 0.9em; }
        .duplicate-set p strong { color: var(--danger); margin-right: 5px;}
        .duplicate-set p code { background-color: #e9ecef; padding: 2px 5px; border-radius: 3px; font-size: 0.95em; word-break: break-all;}
        .duplicate-set ul { list-style: decimal; padding-left: 25px; margin: 10px 0 10px 0; font-size: 0.9em; }
        .duplicate-set li { margin-bottom: 5px; }
        .duplicate-set .delete-duplicates-for-url { position: absolute; top: 15px; right: 15px; }

        .status-cell { width: 100px; text-align: center;}
        .status-badge { padding: 3px 8px; border-radius: 12px; font-size: 0.7rem; font-weight: 600; display: inline-flex; align-items: center; gap: 4px; text-transform: uppercase; letter-spacing: 0.4px; }
        .status-badge i { font-size: 0.8em; }
        .status-active { background-color: var(--success-light); color: #0f5132; border: 1px solid rgba(25, 135, 84, 0.3); }
        .status-inactive { background-color: var(--danger-light); color: #842029; border: 1px solid rgba(220, 53, 69, 0.3); }
        .status-checking { background-color: var(--info-light); color: #055160; border: 1px solid rgba(13, 202, 240, 0.3); }
        .status-unknown { background-color: #e9ecef; color: #495057; border: 1px solid rgba(108, 117, 125, 0.3);}


         .group-item {
             display: flex; align-items: center; gap: 12px; padding: 10px 15px; border: 1px solid var(--border-color);
             border-radius: var(--border-radius); background-color: var(--white); cursor: grab; transition: background-color var(--transition-speed), box-shadow var(--transition-speed);
         }
         .group-item:hover { background-color: #f8f9fa; }
         .group-item.sortable-chosen { background-color: #e9ecef; box-shadow: var(--shadow-medium); }
         .group-item .logo-preview { background-color: transparent; flex-shrink: 0; border: none; }
         .group-drag-handle { cursor: grab; color: var(--grey-dark); padding: 0 5px; flex-shrink: 0; }
         .group-item span { flex-grow: 1; margin-right: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 500; }
         .group-item .edit-group-details { margin-left: auto; flex-shrink: 0; }
         .group-item .edit-group-details i { margin-right: 0; }


         #groups-management-modal .modal-body { max-height: 70vh;}
         #groups-list { grid-template-columns: 1fr; display: grid; gap: 8px; }

         .checkbox-cell { width: 40px; }

    </style>
</head>
<body>

    <div class="dashboard-layout">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <button id="sidebar-toggle" class="sidebar-btn" title="Expandir/Colapsar Menú"><i class="fas fa-bars"></i></button>
                <span class="sidebar-logo-text">Editor M3U Pro+</span>
                 <div class="sidebar-logo"> <i class="fas fa-tv"></i> </div>
             </div>
            <nav class="sidebar-nav">
                 <ul>
                    <li><button id="open-btn" class="sidebar-btn" title="Abrir Archivo M3U"><i class="fas fa-folder-open fa-fw"></i><span class="sidebar-btn-text">Abrir</span></button></li>
                    <li><button id="save-btn" class="sidebar-btn" title="Guardar Lista M3U"><i class="fas fa-save fa-fw"></i><span class="sidebar-btn-text">Guardar</span></button></li>
                    <li><button id="new-list-btn" class="sidebar-btn" title="Crear Nueva Lista"><i class="fas fa-file fa-fw"></i><span class="sidebar-btn-text">Nuevo</span></button></li>
                     <hr style="border-top: 1px solid var(--border-color); width: 70%; margin: 15px auto;">
                     <li><button id="compare-btn" class="sidebar-btn" title="Comparar con Otra Lista"><i class="fas fa-exchange-alt fa-fw"></i><span class="sidebar-btn-text">Comparar</span></button></li>
                    <li><button id="manage-groups-btn" class="sidebar-btn" title="Gestionar Grupos"><i class="fas fa-layer-group fa-fw"></i><span class="sidebar-btn-text">Grupos</span></button></li>
                    <li><button id="validate-urls-btn" class="sidebar-btn" title="Validar URLs (HTTP/S)"><i class="fas fa-network-wired fa-fw"></i><span class="sidebar-btn-text">Validar</span></button></li>
                    <li><button id="find-duplicates-btn" class="sidebar-btn" title="Buscar Duplicados por URL"><i class="fas fa-copy fa-fw"></i><span class="sidebar-btn-text">Duplicados</span></button></li>
                     <li><button id="toggle-favorites-btn" class="sidebar-btn" title="Mostrar Favoritos"><i class="far fa-star"></i><span class="sidebar-btn-text">Favoritos</span></button></li>
                </ul>
                 <input type="file" id="file-input" accept=".m3u,.m3u8" style="display: none;">
                 <input type="file" id="compare-file-input" accept=".m3u,.m3u8" style="display: none;">
            </nav>
            <div class="sidebar-footer">
                <button id="clear-storage-btn" class="sidebar-btn danger" title="Limpiar Sesión Local"><i class="fas fa-eraser fa-fw"></i><span class="sidebar-btn-text">Limpiar</span></button>
            </div>
        </aside>

        <div class="main-area">
            <header class="main-header">
                 <div class="header-logo">Editor M3U Pro+</div>
                <div class="search-container">
                    <div class="search-wrapper">
                        <input type="search" id="search-input" placeholder="Buscar..." aria-label="Buscar canales">
                        <i class="fas fa-search"></i>
                    </div>
                </div>
                 <div class="header-actions">
                    <button id="add-channel-btn-header" class="header-btn"><i class="fas fa-plus"></i> Nuevo Canal</button>
                     <button id="add-group-btn-header" class="header-btn"><i class="fas fa-folder-plus"></i> Nuevo Grupo</button>
                     <button id="expand-groups-btn" class="header-btn"><i class="fas fa-expand-arrows-alt"></i> Expandir</button>
                     <button id="collapse-groups-btn" class="header-btn"><i class="fas fa-compress-arrows-alt"></i> Colapsar</button>
                 </div>
            </header>

            <div class="content-wrapper">

                <div class="list-panel">
                     <div class="list-toolbar">
                         <span id="file-name-display">Ningún archivo cargado</span>
                        <select id="group-filter" aria-label="Filtrar por grupo" class="form-control-sm">
                             <option value="">Todos los Grupos</option>
                        </select>
                         <button class="btn btn-sm btn-outline-danger" id="delete-selected-btn"><i class="fas fa-trash"></i> Eliminar Sel.</button>
                         <button class="btn btn-sm btn-outline-secondary" id="clear-selection-btn"><i class="fas fa-eraser"></i> Limpiar Sel.</button>
                     </div>
                     <div class="table-container">
                         <table id="channels-table">
                             <thead>
                                 <tr>
                                    <th class="checkbox-cell"><input type="checkbox" id="select-all" aria-label="Seleccionar todo lo visible"></th>
                                    <th class="handle-cell"><i class="fas fa-grip-vertical"></i></th>
                                    <th class="logo-cell">Logo</th>
                                    <th class="name-cell sortable" data-sort="name">Nombre <i class="fas fa-sort"></i></th>
                                    <th class="url-cell">URL</th>
                                    <th class="epg-cell sortable" data-sort="tvg-id">EPG ID <i class="fas fa-sort"></i></th>
                                    <th class="ch-num-cell sortable" data-sort="ch-number">Num <i class="fas fa-sort"></i></th>
                                     <th class="status-cell sortable" data-sort="active">Estado <i class="fas fa-sort"></i></th>
                                 </tr>
                             </thead>
                             <tbody id="table-body">
                                <tr><td colspan="8" style="text-align:center; padding: 40px 20px; color: var(--text-light);">Carga un archivo M3U para empezar.</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="editor-panel" id="editor-panel">
                    <div id="editor-placeholder">
                        <i class="fas fa-edit"></i>
                        <p>Selecciona un canal de la lista para ver o editar sus detalles aquí.</p>
                    </div>
                    <div id="editor-form-content" class="hidden">
                        <div class="editor-panel-header">
                             <h3><i class="fas fa-pencil-alt"></i> Editor Básico</h3>
                             <button class="btn-close-editor" id="close-editor-btn" title="Cerrar Editor">&times;</button>
                        </div>
                        <div class="editor-panel-content">
                            <input type="hidden" id="editor-channel-original-index">
                            <img id="editor-logo-preview" src="" alt="Vista previa del logo" class="editor-logo-preview">
                             <div class="form-group">
                                <label for="editor-channel-name">Nombre del Canal</label>
                                <input type="text" id="editor-channel-name" required>
                            </div>
                            <div class="input-group">
                                <div class="form-group">
                                    <label for="editor-channel-tvg-id">EPG ID (tvg-id)</label>
                                    <input type="text" id="editor-channel-tvg-id">
                                </div>
                                 <div class="form-group ch-num-wrapper">
                                    <label for="editor-channel-ch-num">Núm. Canal (ch-number)</label>
                                    <input type="number" id="editor-channel-ch-num" min="-1">
                                 </div>
                            </div>
                            <div class="form-group">
                                <label for="editor-channel-logo">Logo (tvg-logo)</label>
                                <input type="url" id="editor-channel-logo">
                            </div>
                            <div class="form-group">
                                <label for="editor-channel-url">URL del Stream</label>
                                <input type="url" id="editor-channel-url" required>
                            </div>
                             <div class="form-group">
                                <label for="editor-channel-group">Grupo (group-title)</label>
                                 <div class="editor-group-actions">
                                    <input type="text" id="editor-channel-group" list="group-suggestions">
                                     <datalist id="group-suggestions"></datalist>
                                     <button id="editor-group-move-btn" class="btn btn-sm btn-outline-primary" title="Mover canal a este grupo (Guarda cambio de grupo)"><i class="fas fa-folder-tree"></i> Mover</button>
                                     <button id="editor-group-copy-btn" class="btn btn-sm btn-outline-info" title="Copiar este canal a otro grupo"><i class="fas fa-copy"></i> Copiar</button>
                                </div>
                            </div>

                             <div class="form-check-group">
                                 <div class="form-check">
                                    <input type="checkbox" id="editor-fav-channel">
                                    <label for="editor-fav-channel">Favorito</label>
                                </div>
                                <div class="form-check">
                                    <input type="checkbox" id="editor-sync-name">
                                    <label for="editor-sync-name">Sincronizar tvg-name</label>
                                </div>
                                <div class="form-check">
                                    <input type="checkbox" id="editor-hide-channel">
                                     <label for="editor-hide-channel">Ocultar canal</label>
                                 </div>
                             </div>

                             <h6>Ajustes Avanzados / DRM (Opcional)</h6>
                             <div class="form-group">
                                <label for="editor-kodi-license-type">Tipo de Licencia DRM (license_type)</label>
                                <input type="text" id="editor-kodi-license-type">
                             </div>
                             <div class="form-group">
                                <label for="editor-kodi-license-key">Clave/URL de Licencia DRM (license_key)</label>
                                <textarea id="editor-kodi-license-key" rows="2"></textarea>
                             </div>
                             <div class="form-group">
                                 <label for="editor-kodi-stream-headers">Cabeceras del Stream DRM (stream_headers)</label>
                                <textarea id="editor-kodi-stream-headers" rows="2" placeholder="Ej: User-Agent=XYZ&Referer=abc.com"></textarea>
                                <div class="form-check" id="apply-headers-check-container">
                                    <input type="checkbox" id="editor-apply-headers-to-group">
                                    <label for="editor-apply-headers-to-group">Aplicar estas cabeceras a todo el grupo actual</label>
                                </div>
                            </div>
                        </div>
                        <div class="editor-footer">
                             <button type="button" class="btn btn-save" id="editor-save-btn"><i class="fas fa-save"></i> Guardar Todo</button>
                            <button type="button" class="btn btn-danger btn-delete" id="editor-delete-btn"><i class="fas fa-trash"></i> Eliminar Canal</button>
                             <button type="button" class="btn btn-move-top" id="editor-move-top-btn"><i class="fas fa-arrow-up"></i> Mover al Principio</button>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <div id="toast-container"></div>
    <div id="loading-overlay"><div class="spinner"></div><span id="loading-message">Cargando...</span></div>

    <div id="groups-management-modal" class="modal">
         <div class="modal-content" style="max-width: 600px;">
             <div class="modal-header">
                 <h5 class="modal-title">Gestionar Grupos</h5>
                 <button type="button" class="modal-close" data-dismiss="groups-management-modal" aria-label="Cerrar">×</button>
             </div>
             <div class="modal-body">
                 <p>Arrastra <i class="fas fa-grip-lines"></i> para reordenar los grupos. Usa <i class="fas fa-pencil-alt"></i> para editar detalles (nombre, logo).</p>
                 <div id="groups-list"></div>
            </div>
             <div class="modal-footer">
                 <button type="button" class="btn btn-primary" data-dismiss="groups-management-modal">Cerrar</button>
             </div>
         </div>
    </div>
     <div id="group-detail-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="group-modal-title">Editar Detalles del Grupo</h5>
                <button type="button" class="modal-close" data-dismiss="group-detail-modal" aria-label="Cerrar">×</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="modal-group-id">
                <div><label for="modal-group-name">Nombre del Grupo:</label><input type="text" id="modal-group-name" required></div>
                <div><label for="modal-group-logo">URL del Logo del Grupo (opcional):</label><input type="url" id="modal-group-logo"></div>
                <p style="font-size: 0.85em; color: var(--text-light); margin-top: 15px;">Cambiar el nombre actualiza 'group-title' en todos los canales del grupo.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-dismiss="group-detail-modal">Cancelar</button>
                <button type="button" class="btn btn-primary" id="modal-group-save-btn">Guardar Detalles</button>
            </div>
        </div>
    </div>
    <div id="add-group-modal" class="modal">
        <div class="modal-content" style="max-width: 450px;">
             <div class="modal-header"> <h5 class="modal-title">Añadir Nuevo Grupo</h5> <button type="button" class="modal-close" data-dismiss="add-group-modal" aria-label="Cerrar">×</button> </div>
            <div class="modal-body">
                 <div><label for="new-group-name">Nombre del Nuevo Grupo:</label><input type="text" id="new-group-name" required></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-dismiss="add-group-modal">Cancelar</button>
                <button type="button" class="btn btn-primary" id="add-group-confirm-btn">Añadir Grupo</button>
            </div>
         </div>
    </div>
     <div id="compare-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"> <h5 class="modal-title">Comparar Listas M3U</h5> <button type="button" class="modal-close" data-dismiss="compare-modal">×</button> </div>
            <div class="modal-body">
                 <p>Comparando lista <strong><span id="compare-list-a-name">Actual</span></strong> con <strong><span id="compare-list-b-name">Otra</span></strong> basada en URLs.</p>
                 <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                     <div> <h6><i class="fas fa-arrow-down"></i> Sólo en <span class="compare-list-a-name-dynamic">Actual</span> (<span id="count-only-a">0</span>)</h6> <ul id="compare-list-a"></ul> </div>
                    <div> <h6><i class="fas fa-check-double"></i> Comunes (<span id="count-common">0</span>)</h6> <p style="font-size: 0.8em; color: var(--text-light); margin-top: -5px;"><span class="compare-diff">Resaltado</span>=diferencias detectadas.</p> <ul id="compare-list-common"></ul> </div>
                    <div> <h6><i class="fas fa-arrow-up"></i> Sólo en <span class="compare-list-b-name-dynamic">Otra</span> (<span id="count-only-b">0</span>)</h6> <ul id="compare-list-b"></ul> <button class="btn btn-sm btn-success" id="copy-missing-to-a-btn" style="margin-top: 10px;"><i class="fas fa-plus-circle"></i> Añadir Faltantes a <span class="compare-list-a-name-dynamic">Actual</span></button> </div>
                </div>
            </div>
            <div class="modal-footer"> <button type="button" class="btn btn-primary" id="merge-lists-btn"><i class="fas fa-compress-alt"></i> Fusionar (Añadir Nuevos de B a A)</button> <button type="button" class="btn btn-outline-secondary" data-dismiss="compare-modal">Cerrar Comparación</button> </div>
        </div>
    </div>
     <div id="duplicates-modal" class="modal">
         <div class="modal-content">
             <div class="modal-header"> <h5 class="modal-title">Canales con URL Duplicada</h5> <button type="button" class="modal-close" data-dismiss="duplicates-modal">×</button> </div>
             <div class="modal-body" id="duplicates-list-container"> <p style="font-size: 0.9em;">Se encontraron grupos de canales que comparten la misma URL. Puedes eliminar las repeticiones para cada URL, conservando sólo la primera aparición encontrada.</p> <div id="duplicates-list"></div> </div>
             <div class="modal-footer"> <button type="button" class="btn btn-outline-secondary" data-dismiss="duplicates-modal">Cerrar</button> </div>
         </div>
     </div>
     <div id="confirm-modal" class="modal">
         <div class="modal-content">
             <div class="modal-header"> <h5 class="modal-title" id="confirm-modal-title">Confirmar Acción</h5> <button type="button" class="modal-close" data-dismiss="confirm-modal" aria-label="Cerrar">×</button> </div>
             <div class="modal-body"> <p id="confirm-modal-text">¿Estás seguro de que deseas realizar esta acción?</p> </div>
            <div class="modal-footer"> <button type="button" class="btn btn-outline-secondary" id="confirm-modal-cancel-btn" data-dismiss="confirm-modal">Cancelar</button> <button type="button" class="btn btn-danger" id="confirm-modal-confirm-btn">Confirmar</button> </div>
        </div>
     </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script>
        let channels = [];
        let selectedChannelOriginalIndex = null;
        let selectedRowIndices = new Set();
        let showOnlyFavorites = false;
        let currentGroupFilter = '';
        let currentFileName = '';
        let currentSort = { column: null, direction: 'asc' };
        let sortableInstance = null;
        let groupSortableInstance = null;
        let validationInProgress = false;
        let groupOrder = [];
        let collapsedGroups = new Set();
        let comparisonChannels = [];
        let comparisonFileName = '';
        let duplicatesModified = false;
        let isSidebarExpanded = false;

        const LOCAL_STORAGE_KEY = 'iptvEditorDashboard_session_v3';
        const SIDEBAR_STATE_KEY = 'iptvEditorSidebarExpanded_v3';

        const fileInput = document.getElementById('file-input');
        const compareFileInput = document.getElementById('compare-file-input');
        const tableBody = document.getElementById('table-body');
        const selectAllCheckbox = document.getElementById('select-all');
        const searchInput = document.getElementById('search-input');
        const groupFilterSelect = document.getElementById('group-filter');
        const toggleFavoritesBtn = document.getElementById('toggle-favorites-btn');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingMessage = document.getElementById('loading-message');
        const toastContainer = document.getElementById('toast-container');
        const fileNameDisplay = document.getElementById('file-name-display');

        const editorPanel = document.getElementById('editor-panel');
        const editorPlaceholder = document.getElementById('editor-placeholder');
        const editorFormContent = document.getElementById('editor-form-content');
        const editorChannelOriginalIndexInput = document.getElementById('editor-channel-original-index');
        const editorChannelNameInput = document.getElementById('editor-channel-name');
        const editorChannelTvgIdInput = document.getElementById('editor-channel-tvg-id');
        const editorChannelChNumInput = document.getElementById('editor-channel-ch-num');
        const editorChannelLogoInput = document.getElementById('editor-channel-logo');
        const editorLogoPreview = document.getElementById('editor-logo-preview');
        const editorChannelUrlInput = document.getElementById('editor-channel-url');
        const editorChannelGroupInput = document.getElementById('editor-channel-group');
        const groupSuggestionsDatalist = document.getElementById('group-suggestions');
        const groupSuggestionsModalDatalist = document.getElementById('group-suggestions-modal');
        const editorSyncNameCheckbox = document.getElementById('editor-sync-name');
        const editorFavCheckbox = document.getElementById('editor-fav-channel');
        const editorHideChannelCheckbox = document.getElementById('editor-hide-channel');
        const editorKodiLicenseTypeInput = document.getElementById('editor-kodi-license-type');
        const editorKodiLicenseKeyInput = document.getElementById('editor-kodi-license-key');
        const editorKodiStreamHeadersInput = document.getElementById('editor-kodi-stream-headers');
        const applyHeadersCheckbox = document.getElementById('editor-apply-headers-to-group');
        const editorSaveBtn = document.getElementById('editor-save-btn');
        const editorDeleteBtn = document.getElementById('editor-delete-btn');
        const editorMoveTopBtn = document.getElementById('editor-move-top-btn');
        const editorGroupMoveBtn = document.getElementById('editor-group-move-btn');
        const editorGroupCopyBtn = document.getElementById('editor-group-copy-btn');
        const closeEditorBtn = document.getElementById('close-editor-btn');
        const sidebarToggleBtn = document.getElementById('sidebar-toggle');

        const groupsManagementModal = document.getElementById('groups-management-modal');
        const groupDetailModal = document.getElementById('group-detail-modal');
        const addGroupModal = document.getElementById('add-group-modal');
        const groupChangeModal = document.getElementById('group-change-modal');
        const compareModal = document.getElementById('compare-modal');
        const duplicatesModal = document.getElementById('duplicates-modal');
        const confirmModal = document.getElementById('confirm-modal');

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        function handleImageError(img) {
             if (img.id === 'editor-logo-preview') {
                 img.src = '';
                 img.alt = 'No se pudo cargar el logo';
                 img.style.display = 'block';
             } else {
                img.style.display = 'none';
                const fallback = document.createElement('span');
                fallback.textContent = '-';
                 if (img.parentNode) {
                    img.parentNode.appendChild(fallback);
                 }
            }
             img.onerror = null;
        }

        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            let iconClass = 'fa-info-circle';
            if (type === 'success') iconClass = 'fa-check-circle';
            else if (type === 'error') iconClass = 'fa-exclamation-triangle';
            else if (type === 'warning') iconClass = 'fa-exclamation-circle';
            toast.innerHTML = `<i class="fas ${iconClass}"></i> ${escapeHtml(message)}`;
            toastContainer.appendChild(toast);
            requestAnimationFrame(() => {
                 toast.classList.add('show');
            });
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 500);
             }, duration);
        }

        function setLoading(isLoading, message = 'Procesando...') {
            loadingMessage.textContent = message;
            loadingOverlay.style.display = isLoading ? 'flex' : 'none';
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const triggerLocalStorageSave = debounce(() => saveToLocalStorage(), 1500);

        function showConfirmationModal(message, title = 'Confirmar Acción', confirmButtonText = 'Confirmar', confirmButtonClass = 'btn-danger') {
            return new Promise((resolve) => {
                const confirmTitleEl = document.getElementById('confirm-modal-title');
                const confirmTextEl = document.getElementById('confirm-modal-text');
                const confirmBtnEl = document.getElementById('confirm-modal-confirm-btn');
                const cancelBtnEl = document.getElementById('confirm-modal-cancel-btn');

                confirmTitleEl.textContent = title;
                confirmTextEl.innerHTML = message;
                confirmBtnEl.textContent = confirmButtonText;
                confirmBtnEl.className = `btn ${confirmButtonClass}`;

                const close = (result) => {
                     closeModal(confirmModal);
                    confirmBtnEl.onclick = null;
                    cancelBtnEl.onclick = null;
                    resolve(result);
                }

                confirmBtnEl.onclick = () => close(true);
                cancelBtnEl.onclick = () => close(false);

                openModal(confirmModal);
                confirmBtnEl.focus();
            });
        }

        function displayChannelInEditor(originalIndex) {
             const channelIndex = channels.findIndex(ch => ch && ch.originalIndex === originalIndex);
            if (channelIndex === -1) {
                showEditorPlaceholder();
                return;
            }
            const channel = channels[channelIndex];

            selectedChannelOriginalIndex = originalIndex;

            editorChannelOriginalIndexInput.value = originalIndex;
            editorChannelNameInput.value = channel.name || '';
            editorChannelTvgIdInput.value = channel['tvg-id'] || '';
            editorChannelChNumInput.value = channel['ch-number'] || '';
            editorChannelLogoInput.value = channel['tvg-logo'] || '';
            editorLogoPreview.src = channel['tvg-logo'] || '';
            editorLogoPreview.onerror = () => handleImageError(editorLogoPreview);
            editorLogoPreview.style.display = channel['tvg-logo'] ? 'block' : 'none';
            editorChannelUrlInput.value = channel.url || '';
            editorChannelGroupInput.value = channel['group-title'] || '';
            editorFavCheckbox.checked = channel.favorite || false;
            editorSyncNameCheckbox.checked = channel.attributes?.syncTvgName === 'true';
            editorHideChannelCheckbox.checked = channel.attributes?.hidden === 'true';
            const kodiProps = channel.kodiProps || {};
            editorKodiLicenseTypeInput.value = kodiProps['inputstream.adaptive.license_type'] || '';
            editorKodiLicenseKeyInput.value = kodiProps['inputstream.adaptive.license_key'] || '';
            editorKodiStreamHeadersInput.value = kodiProps['inputstream.adaptive.stream_headers'] || '';
            applyHeadersCheckbox.checked = false;

            editorPlaceholder.classList.add('hidden');
            editorFormContent.classList.remove('hidden');
            updateGroupSuggestions();

            document.body.classList.add('editor-visible');

            tableBody.querySelectorAll('.selected-row').forEach(row => row.classList.remove('selected-row'));
            const selectedRow = tableBody.querySelector(`tr.channel-row[data-index="${originalIndex}"]`);
            if (selectedRow) {
                selectedRow.classList.add('selected-row');
                if (typeof selectedRow.scrollIntoViewIfNeeded === "function") {
                    selectedRow.scrollIntoViewIfNeeded({ behavior: 'smooth', block: 'nearest' });
                } else {
                    selectedRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
         }

        function showEditorPlaceholder() {
             selectedChannelOriginalIndex = null;
             editorFormContent.classList.add('hidden');
             editorPlaceholder.classList.remove('hidden');
             document.body.classList.remove('editor-visible');
             tableBody.querySelectorAll('.selected-row').forEach(row => row.classList.remove('selected-row'));
        }

        async function handleEditorSave() {
            const originalIndexStr = editorChannelOriginalIndexInput.value;
            const originalIndex = originalIndexStr !== '' ? parseInt(originalIndexStr) : null;

            if (originalIndex === null) {
                showToast("Ningún canal seleccionado para guardar.", "error");
                return;
            }

            const channelIndex = channels.findIndex(ch => ch && ch.originalIndex === originalIndex);
            if (channelIndex === -1) {
                showToast("Canal seleccionado no encontrado.", "error");
                showEditorPlaceholder();
                return;
            }

            const name = editorChannelNameInput.value.trim();
            const url = editorChannelUrlInput.value.trim();
            const group = editorChannelGroupInput.value.trim();
            const logo = editorChannelLogoInput.value.trim();
            const tvgId = editorChannelTvgIdInput.value.trim();
            const chNum = editorChannelChNumInput.value.trim();
            const isFavorite = editorFavCheckbox.checked;
            const syncName = editorSyncNameCheckbox.checked;
            const hideChannel = editorHideChannelCheckbox.checked;
            const kodiLicenseType = editorKodiLicenseTypeInput.value.trim();
            const kodiLicenseKey = editorKodiLicenseKeyInput.value.trim();
            const kodiStreamHeaders = editorKodiStreamHeadersInput.value.trim();
            const applyHeaders = applyHeadersCheckbox.checked;

            if (!name) { showToast('El nombre del canal es obligatorio.', 'error'); editorChannelNameInput.focus(); return; }
            if (!url || !(/^(https?|rtmp|rtsp|udp|http|hls):/i.test(url) || url.startsWith('/') || url.includes('://'))) {
                showToast('Formato de URL de Stream inválido.', 'error'); editorChannelUrlInput.focus(); return;
            }

            let channelData = channels[channelIndex];
            const oldGroup = channelData['group-title'] || '';

            channelData.name = name;
            channelData.url = url;
            channelData['group-title'] = group;
            channelData['tvg-logo'] = logo;
            channelData['tvg-id'] = tvgId;
            channelData['ch-number'] = chNum;
            channelData['tvg-name'] = syncName ? name : (channelData['tvg-name'] || name);
            channelData.favorite = isFavorite;

            channelData.attributes = channelData.attributes || {};
            channelData.attributes['group-title'] = group;
            channelData.attributes['tvg-logo'] = logo;
            channelData.attributes['tvg-id'] = tvgId;
            channelData.attributes['ch-number'] = chNum;
            channelData.attributes['tvg-name'] = channelData['tvg-name'];
            channelData.attributes['syncTvgName'] = syncName ? 'true' : 'false';
            channelData.attributes['hidden'] = hideChannel ? 'true' : 'false';

            channelData.kodiProps = channelData.kodiProps || {};
            if (kodiLicenseType) channelData.kodiProps['inputstream.adaptive.license_type'] = kodiLicenseType; else delete channelData.kodiProps['inputstream.adaptive.license_type'];
            if (kodiLicenseKey) channelData.kodiProps['inputstream.adaptive.license_key'] = kodiLicenseKey; else delete channelData.kodiProps['inputstream.adaptive.license_key'];
            if (kodiStreamHeaders) channelData.kodiProps['inputstream.adaptive.stream_headers'] = kodiStreamHeaders; else delete channelData.kodiProps['inputstream.adaptive.stream_headers'];


            let appliedHeadersCount = 0;
            let didApplyHeaders = false;
            if (applyHeaders && group && (kodiStreamHeaders || kodiLicenseType || kodiLicenseKey)) {
                const countInGroup = channels.filter(c => (c['group-title'] || '') === group).length;
                const userConfirmedHeaders = await showConfirmationModal(
                     `¿Aplicar los ajustes DRM introducidos a TODOS los ${countInGroup} canales del grupo "${escapeHtml(group)}"? (Esto sobrescribirá ajustes DRM existentes en esos canales)`,
                     'Confirmar Aplicar DRM a Grupo',
                     'Sí, Aplicar a Todo el Grupo',
                     'btn-warning'
                 );

                 if (userConfirmedHeaders) {
                    didApplyHeaders = true;
                     channels.forEach(otherChannel => {
                         if((otherChannel['group-title'] || '') === group ) {
                            otherChannel.kodiProps = otherChannel.kodiProps || {};

                            if (kodiLicenseType) otherChannel.kodiProps['inputstream.adaptive.license_type'] = kodiLicenseType;
                            else delete otherChannel.kodiProps['inputstream.adaptive.license_type'];

                            if (kodiLicenseKey) otherChannel.kodiProps['inputstream.adaptive.license_key'] = kodiLicenseKey;
                            else delete otherChannel.kodiProps['inputstream.adaptive.license_key'];

                            if (kodiStreamHeaders) otherChannel.kodiProps['inputstream.adaptive.stream_headers'] = kodiStreamHeaders;
                            else delete otherChannel.kodiProps['inputstream.adaptive.stream_headers'];

                            if(otherChannel.originalIndex !== originalIndex) {
                                appliedHeadersCount++;
                            }
                         }
                    });
                 } else {
                     showToast('Aplicación de ajustes DRM al grupo cancelada.', 'info');
                 }
             }

            channels[channelIndex] = channelData; // Update current channel always

            if (didApplyHeaders) {
                renderTable();
                 if(appliedHeadersCount > 0) {
                     showToast(`Ajustes DRM actualizados para ${appliedHeadersCount + 1} canales en el grupo.`, 'success');
                } else {
                     showToast(`Ajustes DRM del canal guardados.`, 'success'); // Just saved the current one if no others in group
                 }
             } else {
                 updateSingleRow(originalIndex);
                 showToast('Canal actualizado correctamente.', 'success');
             }

            updateGroupOrderIfNeeded(oldGroup, group);
            updateGroupFilter();
             if (groupsManagementModal.style.display === 'flex') { renderGroupsInModal(); }

            triggerLocalStorageSave();
            displayChannelInEditor(originalIndex); // Keep editor focused
            applyHeadersCheckbox.checked = false; // Reset checkbox
        }


         async function handleEditorDelete() {
            const originalIndexStr = editorChannelOriginalIndexInput.value;
            const originalIndex = originalIndexStr !== '' ? parseInt(originalIndexStr) : null;

             if (originalIndex === null) {
                showToast("Ningún canal seleccionado para eliminar.", "error");
                return;
             }

            const channelIndex = channels.findIndex(ch => ch && ch.originalIndex === originalIndex);
            if (channelIndex === -1) {
                 showToast("Canal seleccionado no encontrado.", "error");
                showEditorPlaceholder();
                return;
             }
            const channelName = channels[channelIndex].name || `Canal #${originalIndex + 1}`;


            const userConfirmed = await showConfirmationModal(
                 `¿Estás seguro que deseas eliminar el canal "<strong>${escapeHtml(channelName)}</strong>"?`,
                 'Confirmar Eliminación',
                 'Sí, Eliminar',
                 'btn-danger'
             );

             if (userConfirmed) {
                const deletedGroup = channels[channelIndex]['group-title'] || '';
                channels.splice(channelIndex, 1);

                selectedRowIndices.delete(originalIndex);
                showEditorPlaceholder();

                let currentIdx = 0;
                 channels.forEach(ch => {
                    ch.originalIndex = currentIdx++;
                });

                updateGroupOrderIfNeeded(deletedGroup, null);
                renderTable();
                updateGroupFilter();
                if (groupsManagementModal.style.display === 'flex') renderGroupsInModal();
                 triggerLocalStorageSave();
                 showToast(`Canal "${escapeHtml(channelName)}" eliminado.`, 'info');
            }
        }


        function handleEditorMoveTop() {
            const originalIndexStr = editorChannelOriginalIndexInput.value;
            const originalIndex = originalIndexStr !== '' ? parseInt(originalIndexStr) : null;
             if (originalIndex === null) return;

            const channelIndex = channels.findIndex(ch => ch && ch.originalIndex === originalIndex);
            if (channelIndex === -1) return;

            const channelToMove = channels.splice(channelIndex, 1)[0];
             if (!channelToMove) return;

             const group = channelToMove['group-title'] || '';

            let insertAtIndex = 0;
            for (let i = 0; i < channels.length; i++) {
                if ((channels[i]['group-title'] || '') === group) {
                     insertAtIndex = i;
                     break;
                }
                 if (group === '' && i === 0) {
                     break;
                 }
                 if (i > 0 && (channels[i]['group-title'] || '') !== group && (channels[i-1]['group-title'] || '') === group) {
                     insertAtIndex = i;
                     break;
                }
             }
             if(channels.length === 0) {
                insertAtIndex = 0;
             } else if (insertAtIndex === 0 && group !== (channels[0]['group-title'] || '') && group !== '') {
                 let foundGroupStart = false;
                 for (let i = 0; i < channels.length; i++) {
                    if ((channels[i]['group-title'] || '') === group) {
                         insertAtIndex = i;
                         foundGroupStart = true;
                         break;
                    }
                }
                 if (!foundGroupStart) {
                     const groupOrderIndex = groupOrder.indexOf(group);
                     if(groupOrderIndex !== -1) {
                        let precedingGroup = groupOrderIndex > 0 ? groupOrder[groupOrderIndex - 1] : null;
                        if (precedingGroup !== null) {
                             for (let i = channels.length - 1; i >= 0; i--) {
                                if ((channels[i]['group-title'] || '') === precedingGroup) {
                                    insertAtIndex = i + 1; break;
                                }
                             }
                         }

                     } else {
                         insertAtIndex = channels.length;
                     }
                 }
             }

             channels.splice(insertAtIndex, 0, channelToMove);

             channels.forEach((ch, idx) => ch.originalIndex = idx);

             showToast('Canal movido al principio del grupo.', 'info');
             renderTable();
             triggerLocalStorageSave();
            const newOriginalIndex = channelToMove.originalIndex;
            displayChannelInEditor(newOriginalIndex);
         }

        function handleEditorGroupMove() {
             const originalIndexStr = editorChannelOriginalIndexInput.value;
            const originalIndex = originalIndexStr !== '' ? parseInt(originalIndexStr) : null;
            const targetGroup = editorChannelGroupInput.value.trim();


             if (originalIndex === null) {
                showToast("Primero selecciona un canal para mover.", "warning");
                return;
            }
             const channelIndex = channels.findIndex(ch => ch && ch.originalIndex === originalIndex);
            if (channelIndex === -1) {
                 showToast("Canal no encontrado.", "error");
                return;
             }

            const oldGroup = channels[channelIndex]['group-title'] || '';

             if (targetGroup === oldGroup) {
                 showToast('El canal ya está en este grupo.', 'info');
                 return;
            }

            channels[channelIndex]['group-title'] = targetGroup;
            channels[channelIndex].attributes = channels[channelIndex].attributes || {};
            channels[channelIndex].attributes['group-title'] = targetGroup;

            updateGroupOrderIfNeeded(oldGroup, targetGroup);
            renderTable();
            updateGroupFilter();
            if (groupsManagementModal.style.display === 'flex') { renderGroupsInModal(); }
            showToast(`Canal movido al grupo "${targetGroup || '(Sin Grupo)'}".`, 'success');
            triggerLocalStorageSave();
             displayChannelInEditor(originalIndex);
         }


         function handleEditorGroupCopy() {
             const originalIndexStr = editorChannelOriginalIndexInput.value;
             const originalIndex = originalIndexStr !== '' ? parseInt(originalIndexStr) : null;
             if (originalIndex === null) return;

             const channelIndex = channels.findIndex(ch => ch && ch.originalIndex === originalIndex);
            if (channelIndex === -1) return;

            const targetGroup = prompt("Introduce el nombre del grupo al que deseas copiar este canal:");
             if (targetGroup === null) return;
            const targetGroupName = targetGroup.trim();

             const channelToCopy = JSON.parse(JSON.stringify(channels[channelIndex]));
            channelToCopy['group-title'] = targetGroupName;
            channelToCopy.attributes = { ...channelToCopy.attributes, 'group-title': targetGroupName };
            channelToCopy.originalIndex = -1;
             channelToCopy.active = null;

            channels.push(channelToCopy);

             channels.forEach((ch, idx) => ch.originalIndex = idx);

            updateGroupOrderIfNeeded(null, targetGroupName);
            renderTable();
             updateGroupFilter();
            if (groupsManagementModal.style.display === 'flex') { renderGroupsInModal(); }
             showToast(`Canal copiado al grupo "${targetGroupName || '(Sin Grupo)'}".`, 'success');
            triggerLocalStorageSave();
         }

         function initEditorPanelListeners() {
            editorSaveBtn.addEventListener('click', handleEditorSave);
             editorDeleteBtn.addEventListener('click', handleEditorDelete);
            editorMoveTopBtn.addEventListener('click', handleEditorMoveTop);
             editorGroupMoveBtn.addEventListener('click', handleEditorGroupMove);
             editorGroupCopyBtn.addEventListener('click', handleEditorGroupCopy);
             closeEditorBtn.addEventListener('click', showEditorPlaceholder);

            editorChannelLogoInput.addEventListener('input', () => {
                editorLogoPreview.src = editorChannelLogoInput.value.trim();
                editorLogoPreview.style.display = editorChannelLogoInput.value.trim() ? 'block' : 'none';
            });
         }


        function initEventListeners() {
            document.getElementById('open-btn').addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            document.getElementById('compare-btn').addEventListener('click', () => compareFileInput.click());
            compareFileInput.addEventListener('change', handleCompareFileSelect);
            document.getElementById('save-btn').addEventListener('click', saveToFile);
            document.getElementById('new-list-btn').addEventListener('click', handleNewList);
             document.getElementById('manage-groups-btn').addEventListener('click', openGroupsManagementModal);
            document.getElementById('validate-urls-btn').addEventListener('click', validateAllUrls);
            document.getElementById('find-duplicates-btn').addEventListener('click', findAndShowDuplicatesModal);
             toggleFavoritesBtn.addEventListener('click', toggleFavoritesFilter);
             document.getElementById('clear-storage-btn').addEventListener('click', handleClearStorage);
             sidebarToggleBtn.addEventListener('click', toggleSidebar);

            document.getElementById('add-channel-btn-header').addEventListener('click', addNewChannelToList);
            document.getElementById('add-group-btn-header').addEventListener('click', () => openModal(addGroupModal));
            document.getElementById('expand-groups-btn').addEventListener('click', expandAllGroups);
            document.getElementById('collapse-groups-btn').addEventListener('click', collapseAllGroups);

             searchInput.addEventListener('input', debounce(renderTable, 300));
            groupFilterSelect.addEventListener('change', (e) => { currentGroupFilter = e.target.value; renderTable(); triggerLocalStorageSave(); });
            document.getElementById('delete-selected-btn').addEventListener('click', deleteSelectedChannels);
            document.getElementById('clear-selection-btn').addEventListener('click', clearMultiSelection);

            document.querySelectorAll('#channels-table th.sortable').forEach(th => { th.addEventListener('click', () => handleSort(th.dataset.sort)); });
             selectAllCheckbox.addEventListener('change', handleSelectAllVisible);
             tableBody.addEventListener('change', handleRowCheckboxChange);
             tableBody.addEventListener('click', handleTableBodyClick);

             initEditorPanelListeners();

             document.querySelectorAll('.modal').forEach(modal => {
                 const closeButtons = modal.querySelectorAll('.modal-close, [data-dismiss]');
                 closeButtons.forEach(btn => {
                     btn.addEventListener('click', (e) => {
                         e.stopPropagation();
                        const targetModalId = btn.getAttribute('data-dismiss');
                        const targetModal = targetModalId ? document.getElementById(targetModalId) : modal;
                        if (targetModal) closeModal(targetModal);
                    });
                 });
                 modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(modal); });
            });

             document.getElementById('add-group-confirm-btn').addEventListener('click', handleAddNewGroup);
             document.getElementById('modal-group-save-btn').addEventListener('click', handleGroupDetailModalSave);
             // No confirm button for group change modal anymore
             document.getElementById('copy-missing-to-a-btn')?.addEventListener('click', copyMissingChannelsToA);
             document.getElementById('merge-lists-btn')?.addEventListener('click', mergeLists);
             document.getElementById('duplicates-list')?.addEventListener('click', handleDeleteDuplicatesForUrl);
        }

         function openModal(modalElement) {
            if (modalElement) modalElement.style.display = 'flex';
         }

        function closeModal(modalElement) {
             if (modalElement) modalElement.style.display = 'none';
        }
        function closeModalById(modalId) {
             const modal = document.getElementById(modalId);
             closeModal(modal);
        }

         function addNewChannelToList() {
            const newChannel = {
                 name: 'Nuevo Canal',
                 url: '',
                 attributes: {},
                 kodiProps: {},
                 vlcOptions: {},
                'group-title': currentGroupFilter || '',
                 favorite: false,
                 active: null,
                originalIndex: channels.length
             };

            channels.push(newChannel);
            channels.forEach((ch, idx) => ch.originalIndex = idx);

             updateGroupOrderIfNeeded(null, newChannel['group-title']);
             renderTable();
            updateGroupFilter();
            showToast('Nuevo canal añadido. Edita sus detalles.', 'success');
            triggerLocalStorageSave();

            displayChannelInEditor(newChannel.originalIndex);
             editorChannelNameInput.focus();
        }

         function handleAddNewGroup() {
            const newGroupNameInput = document.getElementById('new-group-name');
            const newGroupName = newGroupNameInput.value.trim();
             if (!newGroupName) {
                 showToast('El nombre del grupo no puede estar vacío.', 'warning');
                 newGroupNameInput.focus();
                 return;
            }
             if (groupOrder.includes(newGroupName)) {
                showToast(`El grupo "${escapeHtml(newGroupName)}" ya existe.`, 'warning');
                return;
            }

            let affectedGroups = new Set();
            let movedCount = 0;
            // Move selected channels to this new group
            if(selectedRowIndices.size > 0){
                 selectedRowIndices.forEach(originalIndex => {
                     const index = channels.findIndex(ch => ch && ch.originalIndex === originalIndex);
                     if (index !== -1) {
                        affectedGroups.add(channels[index]['group-title'] || ''); // Track old groups
                         channels[index]['group-title'] = newGroupName;
                         channels[index].attributes = channels[index].attributes || {};
                         channels[index].attributes['group-title'] = newGroupName;
                         movedCount++;
                     }
                 });
             }

             groupOrder.push(newGroupName);
             updateGroupSuggestions();
            updateGroupFilter();
            if (groupsManagementModal.style.display === 'flex') renderGroupsInModal();

             // Check if any old groups need removing from groupOrder
             affectedGroups.forEach(oldGroup => updateGroupOrderIfNeeded(oldGroup, null));

             closeModal(addGroupModal);
             newGroupNameInput.value = '';

             if (movedCount > 0) {
                showToast(`Grupo "${escapeHtml(newGroupName)}" creado y ${movedCount} canales movidos.`, 'success');
                clearMultiSelection(false); // Clear selection after move
            } else {
                 showToast(`Nuevo grupo "${escapeHtml(newGroupName)}" añadido.`, 'success');
            }

            triggerLocalStorageSave();
             renderTable(); // Full re-render needed to show moved channels in new group
         }


         function expandAllGroups() {
             collapsedGroups.clear();
             renderTable();
         }

        function collapseAllGroups() {
             groupOrder.forEach(group => collapsedGroups.add(group));
             renderTable();
         }


         function handleTableBodyClick(e) {
            if (e.target.closest('.row-checkbox, .drag-handle, .action-change-group, .action-edit, .action-fav, .action-delete')) {
                 return;
             }

            const row = e.target.closest('tr.channel-row');
            if (row && row.dataset.index !== undefined) {
                const originalIndex = parseInt(row.dataset.index);
                if (!isNaN(originalIndex)) {
                    displayChannelInEditor(originalIndex);
                }
            } else if (e.target.closest('.group-header-row')) {
                 const groupHeader = e.target.closest('.group-header-row');
                if(groupHeader && groupHeader.dataset.group !== undefined) {
                     toggleGroupCollapse(groupHeader.dataset.group);
                 }
            } else {
                // Click outside - now does nothing by default. Close button is explicit.
            }
        }

        function handleSelectAllVisible(e) {
             const isChecked = e.target.checked;
             const visibleRows = tableBody.querySelectorAll('tr.channel-row:not(.hidden)');
             visibleRows.forEach(row => {
                 const index = parseInt(row.dataset.index);
                 if (!isNaN(index)) {
                     const checkbox = row.querySelector('.row-checkbox');
                     if (isChecked) selectedRowIndices.add(index);
                     else selectedRowIndices.delete(index);
                     if(checkbox) checkbox.checked = isChecked;
                }
             });
             updateSelectAllCheckboxState();
         }

         function handleRowCheckboxChange(e) {
             if (!e.target.classList.contains('row-checkbox')) return;
            const checkbox = e.target;
             const index = parseInt(checkbox.dataset.index);
             if (isNaN(index)) return;

             if (checkbox.checked) selectedRowIndices.add(index);
             else selectedRowIndices.delete(index);
             updateSelectAllCheckboxState();
        }

         function updateSelectAllCheckboxState() {
             const visibleCheckboxes = Array.from(tableBody.querySelectorAll('tr.channel-row:not(.hidden) .row-checkbox'));
             const numVisible = visibleCheckboxes.length;
             if (numVisible === 0) {
                 selectAllCheckbox.checked = false;
                 selectAllCheckbox.indeterminate = false;
                 return;
             }
             const numSelectedVisible = visibleCheckboxes.filter(cb => {
                const idx = parseInt(cb.dataset.index);
                return !isNaN(idx) && selectedRowIndices.has(idx);
            }).length;

             if (numSelectedVisible === numVisible) {
                 selectAllCheckbox.checked = true; selectAllCheckbox.indeterminate = false;
             } else if (numSelectedVisible > 0) {
                 selectAllCheckbox.checked = false; selectAllCheckbox.indeterminate = true;
             } else {
                 selectAllCheckbox.checked = false; selectAllCheckbox.indeterminate = false;
            }
        }

        function clearMultiSelection(showMsg = true) {
             selectedRowIndices.clear();
             tableBody.querySelectorAll('.row-checkbox').forEach(cb => cb.checked = false);
             updateSelectAllCheckboxState();
             if (showMsg) showToast('Selección de canales limpiada.', 'info', 1500);
        }

         async function deleteSelectedChannels() {
             if (selectedRowIndices.size === 0) {
                 showToast('No hay canales seleccionados (marque las casillas).', 'warning');
                 return;
            }
             const count = selectedRowIndices.size;

             const userConfirmed = await showConfirmationModal(
                `¿Estás seguro de que deseas eliminar los ${count} canales seleccionados? Esta acción no se puede deshacer.`,
                'Confirmar Eliminación Múltiple',
                `Eliminar ${count} Canales`,
                 'btn-danger'
            );

             if (userConfirmed) {
                let affectedGroups = new Set();
                 const originalIndicesToDelete = Array.from(selectedRowIndices);

                 channels = channels.filter(channel => {
                     const shouldKeep = !selectedRowIndices.has(channel.originalIndex);
                     if (!shouldKeep) {
                         affectedGroups.add(channel['group-title'] || '');
                         if (channel.originalIndex === selectedChannelOriginalIndex) {
                             showEditorPlaceholder();
                        }
                    }
                    return shouldKeep;
                 });

                 selectedRowIndices.clear();

                 channels.forEach((ch, idx) => ch.originalIndex = idx);


                 affectedGroups.forEach(group => updateGroupOrderIfNeeded(group, null));
                renderTable();
                 updateGroupFilter();
                 if (groupsManagementModal.style.display === 'flex') renderGroupsInModal();
                triggerLocalStorageSave();
                 showToast(`${count} canales eliminados correctamente.`, 'info');
            }
         }


        function initSortable() {
            if (sortableInstance) sortableInstance.destroy();
            sortableInstance = new Sortable(tableBody, {
                 animation: 150,
                handle: '.drag-handle',
                 filter: '.group-header-row, input, button, select',
                 preventOnFilter: true,
                 draggable: '.channel-row',
                onEnd: (evt) => {
                    if (evt.oldIndex === evt.newIndex && evt.from === evt.to) return;
                    const movedRow = evt.item;
                    if (!movedRow || !movedRow.dataset.index) return;
                    const originalDataIndex = parseInt(movedRow.dataset.index);

                    const currentArrayIndex = channels.findIndex(ch => ch && ch.originalIndex === originalDataIndex);
                     if (currentArrayIndex === -1 || !channels[currentArrayIndex]) {
                         console.error("Error: Canal movido no encontrado. Índice:", originalDataIndex);
                        renderTable(); return;
                    }

                    const movedChannel = channels.splice(currentArrayIndex, 1)[0];

                    let targetGroup = '';
                     let sibling = movedRow.previousElementSibling;
                     while(sibling) {
                         if (sibling.classList.contains('group-header-row')) {
                             targetGroup = sibling.dataset.group || '';
                            break;
                         }
                         sibling = sibling.previousElementSibling;
                     }
                     const oldGroup = movedChannel['group-title'] || '';
                    movedChannel['group-title'] = targetGroup;
                     movedChannel.attributes = movedChannel.attributes || {};
                    movedChannel.attributes['group-title'] = targetGroup;


                    const visibleRows = Array.from(evt.to.children).filter(el => el.classList.contains('channel-row'));
                     const newVisualIndex = visibleRows.indexOf(movedRow);

                    let insertBeforeOriginalIndex = -1;
                    if (newVisualIndex < visibleRows.length - 1) {
                        const nextRow = visibleRows[newVisualIndex + 1];
                         if (nextRow && nextRow.dataset && nextRow.dataset.index) {
                            insertBeforeOriginalIndex = parseInt(nextRow.dataset.index);
                         }
                    }

                    let targetArrayIndex = -1;
                    if (insertBeforeOriginalIndex !== -1) {
                        targetArrayIndex = channels.findIndex(ch => ch && ch.originalIndex === insertBeforeOriginalIndex);
                     }


                     if (targetArrayIndex !== -1) {
                         channels.splice(targetArrayIndex, 0, movedChannel);
                     } else {
                         channels.push(movedChannel);
                    }

                    channels.forEach((ch, idx) => ch.originalIndex = idx);

                    updateGroupOrderIfNeeded(oldGroup, targetGroup);

                    renderTable();
                    triggerLocalStorageSave();
                     showToast(`Canal movido a "${targetGroup === '' ? '(Sin Grupo)' : escapeHtml(targetGroup)}".`, 'info', 2000);

                    displayChannelInEditor(movedChannel.originalIndex);
                 }
            });
        }


        function openGroupsManagementModal() {
             renderGroupsInModal();
            initGroupModalSortable();
             openModal(groupsManagementModal);
         }

        function renderGroupsInModal() {
             const groupsListDiv = groupsManagementModal.querySelector('#groups-list');
             groupsListDiv.innerHTML = '';
             if (groupOrder.length === 0) {
                 groupsListDiv.innerHTML = '<p style="color: var(--text-light); font-style: italic;">No hay grupos definidos.</p>';
                return;
            }

             const groupFragment = document.createDocumentFragment();
            groupOrder.forEach(group => {
                 const groupItem = document.createElement('div');
                 groupItem.className = 'group-item';
                 groupItem.dataset.group = group;
                 const groupDisplayName = group === '' ? '(Sin Grupo)' : escapeHtml(group);
                 const firstChannelInGroup = channels.find(ch => (ch['group-title'] || '') === group);
                 const groupLogo = firstChannelInGroup?.['group-logo'];
                const editButtonHtml = group !== ''
                     ? `<button class="btn btn-sm btn-outline-secondary edit-group-details" data-group="${escapeHtml(group)}" title="Editar detalles del grupo"><i class="fas fa-pencil-alt"></i></button>`
                    : '<span style="width: 30px;"></span>';

                 groupItem.innerHTML = `
                     <i class="fas fa-grip-lines group-drag-handle" title="Arrastrar para reordenar"></i>
                    <span style="flex-grow: 1;">${groupDisplayName}</span>
                     ${groupLogo ? `<img src="${escapeHtml(groupLogo)}" class="logo-preview" style="max-width:40px; max-height:20px; border:none; background:transparent;" onerror="handleImageError(this)">` : '<span style="width:40px;"></span>'}
                     ${editButtonHtml}
                 `;
                 groupFragment.appendChild(groupItem);

                const editBtn = groupItem.querySelector('.edit-group-details');
                 if (editBtn) {
                     editBtn.addEventListener('click', (e) => {
                         e.stopPropagation();
                         openGroupDetailModal(editBtn.dataset.group);
                     });
                 }
             });
             groupsListDiv.appendChild(groupFragment);
        }

        function initGroupModalSortable() {
             const groupsListDiv = groupsManagementModal.querySelector('#groups-list');
             if (groupSortableInstance) groupSortableInstance.destroy();
             groupSortableInstance = new Sortable(groupsListDiv, {
                 animation: 150,
                handle: '.group-drag-handle',
                filter:'.edit-group-details',
                preventOnFilter: true,
                 onEnd: (evt) => {
                     if (evt.oldIndex === evt.newIndex) return;
                     const [movedGroup] = groupOrder.splice(evt.oldIndex, 1);
                     groupOrder.splice(evt.newIndex, 0, movedGroup);
                     renderTable();
                     renderGroupsInModal();
                    updateGroupFilter();
                    triggerLocalStorageSave();
                    showToast('Orden de grupos actualizado.', 'info', 1500);
                 }
             });
         }

        function openGroupDetailModal(groupName) {
            if (groupName === undefined || groupName === null || groupName === '') {
                showToast('No se pueden editar los detalles para "(Sin Grupo)".', 'warning');
                return;
             }
             const firstChannel = channels.find(ch => ch['group-title'] === groupName);
             const groupLogo = firstChannel?.['group-logo'] || '';
             document.getElementById('modal-group-id').value = groupName;
             document.getElementById('modal-group-name').value = groupName || '';
             document.getElementById('modal-group-logo').value = groupLogo;
             document.getElementById('group-modal-title').textContent = `Editar Grupo: ${escapeHtml(groupName)}`;
             openModal(groupDetailModal);
             document.getElementById('modal-group-name').focus();
        }


        async function handleGroupDetailModalSave() {
             const oldGroup = document.getElementById('modal-group-id').value;
             const newGroupNameInput = document.getElementById('modal-group-name');
             const newGroupLogoInput = document.getElementById('modal-group-logo');
             const newGroup = newGroupNameInput.value.trim();
             const groupLogo = newGroupLogoInput.value.trim();

             if (!newGroup) {
                showToast('El nombre del grupo no puede estar vacío.', 'error');
                 newGroupNameInput.focus();
                 return;
            }

            const firstOldChannel = channels.find(ch => ch['group-title'] === oldGroup);
             const oldLogo = firstOldChannel?.['group-logo'] || '';

             if (newGroup === oldGroup && groupLogo === oldLogo) {
                 showToast('No se detectaron cambios en nombre o logo del grupo.', 'info');
                closeModal(groupDetailModal);
                 return;
            }

            if (newGroup !== oldGroup && groupOrder.includes(newGroup)) {
                 const userConfirmed = await showConfirmationModal(
                     `El grupo "${escapeHtml(newGroup)}" ya existe. ¿Deseas fusionar los canales del grupo "${escapeHtml(oldGroup)}" en él?`,
                    'Confirmar Fusión de Grupos', 'Sí, Fusionar', 'btn-warning'
                 );
                 if (!userConfirmed) { newGroupNameInput.focus(); return; }
            }


             channels.forEach(ch => {
                if (ch['group-title'] === oldGroup) {
                     ch['group-title'] = newGroup;
                     ch.attributes = ch.attributes || {};
                    ch.attributes['group-title'] = newGroup;
                    ch['group-logo'] = groupLogo;
                    ch.attributes['group-logo'] = groupLogo;
                 }
             });

             updateGroupOrderAfterRename(oldGroup, newGroup);
             renderTable();
             renderGroupsInModal();
             updateGroupFilter();
            showToast(`Grupo "${escapeHtml(oldGroup)}" actualizado a "${escapeHtml(newGroup)}".`, 'success');
             closeModal(groupDetailModal);
            triggerLocalStorageSave();
            if (selectedChannelOriginalIndex !== null) {
                 const selChannel = channels.find(ch => ch && ch.originalIndex === selectedChannelOriginalIndex);
                if(selChannel && selChannel['group-title'] === newGroup) {
                    displayChannelInEditor(selectedChannelOriginalIndex);
                }
            }
         }


        function updateGroupSuggestions(targetDatalist = groupSuggestionsDatalist) {
             targetDatalist.innerHTML = '';
             groupOrder.forEach(group => {
                 if (group !== '') {
                     targetDatalist.insertAdjacentHTML('beforeend', `<option value="${escapeHtml(group)}">`);
                 }
             });
             targetDatalist.insertAdjacentHTML('beforeend', `<option value="">(Sin Grupo)</option>`);
         }


        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            currentFileName = file.name;
            fileNameDisplay.textContent = `${escapeHtml(currentFileName)}`;
             fileNameDisplay.classList.add('loaded');
            setLoading(true, 'Leyendo archivo M3U...');
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                     channels = parseM3U(ev.target.result);
                     channels.forEach((ch, idx) => {
                         ch.originalIndex = idx;
                         ch.active = null;
                        ch.favorite = ch.attributes?.favorite === 'true' || false;
                        ch.attributes = ch.attributes || {};
                        ch.kodiProps = ch.kodiProps || {};
                        ch.vlcOptions = ch.vlcOptions || {};
                     });
                    updateGroupOrder();
                    collapsedGroups.clear();
                    showEditorPlaceholder();
                     showToast(`Archivo "${escapeHtml(currentFileName)}" cargado (${channels.length} canales)`, 'success');
                } catch (error) {
                     showToast(`Error procesando archivo: ${escapeHtml(error.message)}`, 'error', 5000);
                    channels = [];
                    groupOrder = [];
                    collapsedGroups.clear();
                    showEditorPlaceholder();
                    fileNameDisplay.textContent = 'Error al cargar archivo';
                    fileNameDisplay.classList.remove('loaded');
                    console.error("Error parsing M3U:", error);
                 } finally {
                     clearMultiSelection(false);
                    currentSort = { column: null, direction: 'asc' };
                     renderTable();
                    updateGroupFilter();
                    setLoading(false);
                    fileInput.value = '';
                    triggerLocalStorageSave();
                 }
             };
             reader.onerror = () => {
                 showToast('Error al leer el archivo.', 'error');
                 setLoading(false);
                fileInput.value = '';
                 fileNameDisplay.textContent = 'Error al leer archivo';
                 fileNameDisplay.classList.remove('loaded');
            };
            reader.readAsText(file);
        }

         function parseM3U(content) {
            const lines = content.split(/[\r\n]+/).map(line => line.trim()).filter(line => line);
             const parsedChannels = [];
             let currentChannel = null;
             let currentGroupFromEXTGRP = '';
             let fileAttributes = {};

             if (!lines[0] || !lines[0].startsWith('#EXTM3U')) {
                 console.warn("El archivo no empieza con #EXTM3U");
             } else {
                const headerLine = lines[0];
                const headerAttrs = headerLine.substring(7).trim();
                const attrRegex = /([a-zA-Z0-9-]+(?:[:\.]?[a-zA-Z0-9-]+)*)=(?:"([^"]*)"|([^,\s]*))/g;
                let match;
                while ((match = attrRegex.exec(headerAttrs))) {
                     const key = match[1].trim();
                    const value = (match[2] !== undefined ? match[2] : match[3])?.trim();
                     if (key && value !== undefined) fileAttributes[key] = value;
                }
            }

             lines.forEach((line, index) => {
                 if (line.startsWith('#EXTINF:')) {
                     currentChannel = { name: `Canal ${parsedChannels.length + 1}`, url: null, kodiProps: {}, vlcOptions: {}, attributes: {}, favorite: false, active: null, originalIndex: -1 };
                     try {
                         const infoMatch = line.match(/^#EXTINF:(-?\d+)(.*),(.*)$/);
                         if (!infoMatch) throw new Error('Formato #EXTINF inválido');
                         const attributesPart = infoMatch[2].trim();
                         currentChannel.name = infoMatch[3].trim() || currentChannel.name;

                         const attrRegex = /([a-zA-Z0-9-]+(?:[:\.]?[a-zA-Z0-9-]+)*)=(?:"([^"]*)"|([^,\s]*))/g;
                        let match;
                        while ((match = attrRegex.exec(attributesPart))) {
                            const key = match[1].trim();
                             const value = (match[2] !== undefined ? match[2] : match[3])?.trim();
                            if (key && value !== undefined) {
                                if (key.toLowerCase() !== 'favorite') {
                                    currentChannel.attributes[key] = value;
                                } else {
                                    currentChannel.favorite = (value === 'true');
                                }
                             }
                        }

                         currentChannel['group-title'] = currentChannel.attributes['group-title'] || currentGroupFromEXTGRP || '';
                         currentChannel['tvg-logo'] = currentChannel.attributes['tvg-logo'] || '';
                         currentChannel['tvg-id'] = currentChannel.attributes['tvg-id'] || '';
                         currentChannel['tvg-name'] = currentChannel.attributes['tvg-name'] || (currentChannel['tvg-id'] ? currentChannel.name : currentChannel.name);
                         currentChannel['group-logo'] = currentChannel.attributes['group-logo'] || '';
                        currentChannel['ch-number'] = currentChannel.attributes['ch-number'] || '';
                        currentChannel.attributes['hidden'] = currentChannel.attributes['hidden'] || 'false';
                         currentChannel.attributes['syncTvgName'] = currentChannel.attributes['syncTvgName'] || 'false';


                     } catch (e) {
                         console.warn(`Error procesando #EXTINF en línea ${index + 1}: ${e.message}. Saltando.`);
                         currentChannel = null;
                     }
                 } else if (line.startsWith('#KODIPROP:') && currentChannel) {
                     const propMatch = line.match(/#KODIPROP:(.+?)=(.*)/);
                     if (propMatch && propMatch[1] && propMatch[2]) {
                         currentChannel.kodiProps[propMatch[1].trim().toLowerCase()] = propMatch[2].trim();
                     }
                 } else if (line.startsWith('#EXTVLCOPT:') && currentChannel) {
                     const vlcMatch = line.match(/#EXTVLCOPT:(.+?)=(.+)/);
                     if (vlcMatch && vlcMatch[1] && vlcMatch[2]) {
                         currentChannel.vlcOptions[vlcMatch[1].trim().toLowerCase()] = vlcMatch[2].trim();
                     }
                } else if (line.startsWith('#EXTGRP:')) {
                     currentGroupFromEXTGRP = line.substring(line.indexOf(':') + 1).trim();
                } else if (!line.startsWith('#') && currentChannel && !currentChannel.url) {
                    const isValidUrl = /^(https?|rtmp|rtsp|udp|http|hls):/i.test(line) || line.startsWith('/') || line.includes('://');
                    if (isValidUrl) {
                        currentChannel.url = line;
                        if (currentChannel.attributes.hidden !== 'true') {
                            currentChannel.originalIndex = parsedChannels.length;
                            parsedChannels.push(currentChannel);
                         } else {
                            console.log(`Saltando canal oculto: ${currentChannel.name}`);
                        }
                        currentChannel = null;
                    } else {
                        console.warn(`Línea ${index + 1} tras #EXTINF no es URL válida: "${line}". Saltando.`);
                        currentChannel = null;
                    }
                 } else if (!line.startsWith('#') && !currentChannel) {
                     const isValidUrl = /^(https?|rtmp|rtsp|udp|http|hls):/i.test(line) || line.startsWith('/') || line.includes('://');
                    if(isValidUrl) {
                         parsedChannels.push({
                             name: `Canal ${parsedChannels.length + 1}`, url: line, kodiProps: {}, vlcOptions: {}, attributes: {}, favorite: false, active: null, originalIndex: parsedChannels.length,
                             'group-title': currentGroupFromEXTGRP || '',
                            'tvg-id': '', 'tvg-logo': '', 'tvg-name': '', 'ch-number': '',
                            'group-logo': ''
                         });
                     }
                 }
             });
            return parsedChannels;
         }


        function saveToFile() {
             if (channels.length === 0) { showToast('No hay canales para guardar.', 'warning'); return; }
             setLoading(true, 'Generando archivo M3U...');
             let m3uContent = '#EXTM3U\n';
             let currentSavedGroup = null;

             const channelsToSave = channels.filter(ch => ch.attributes?.hidden !== 'true');

             const sortedChannelsToSave = [...channelsToSave].sort((a, b) => {
                const groupA = a['group-title'] || ''; const groupB = b['group-title'] || '';
                const indexA = groupOrder.indexOf(groupA); const indexB = groupOrder.indexOf(groupB);
                 const effectiveIndexA = indexA === -1 ? Infinity : indexA;
                const effectiveIndexB = indexB === -1 ? Infinity : indexB;
                 if (effectiveIndexA !== effectiveIndexB) return effectiveIndexA - effectiveIndexB;
                return a.originalIndex - b.originalIndex;
             });

             sortedChannelsToSave.forEach(channel => {
                 const channelGroup = channel['group-title'] || '';
                 if (channelGroup && channelGroup !== currentSavedGroup) {
                     m3uContent += `#EXTGRP:${channelGroup}\n`;
                     currentSavedGroup = channelGroup;
                } else if (!channelGroup && currentSavedGroup !== '') {
                     currentSavedGroup = '';
                }

                 let extinfLine = '#EXTINF:-1';

                 const finalAttributes = { ...channel.attributes };
                 finalAttributes['tvg-id'] = channel['tvg-id'] || '';
                 finalAttributes['tvg-name'] = channel['tvg-name'] || channel.name || '';
                 finalAttributes['tvg-logo'] = channel['tvg-logo'] || '';
                 finalAttributes['group-title'] = channelGroup;
                 if (channel['group-logo']) finalAttributes['group-logo'] = channel['group-logo']; else delete finalAttributes['group-logo'];
                if (channel['ch-number']) finalAttributes['ch-number'] = channel['ch-number']; else delete finalAttributes['ch-number'];
                if (channel.favorite) finalAttributes['favorite'] = 'true'; else delete finalAttributes['favorite'];


                 for (const key in finalAttributes) {
                    if (finalAttributes[key] === '' || finalAttributes[key] === null || finalAttributes[key] === undefined || key === 'hidden' || key === 'syncTvgName') {
                         delete finalAttributes[key];
                    }
                 }

                 for (const key in finalAttributes) {
                     let value = finalAttributes[key];
                     if (typeof value !== 'string') value = String(value);
                     const needsQuotes = value.includes(' ') || value.includes(',') || value.includes('"');
                     if (needsQuotes) { value = `"${value.replace(/"/g, '')}"`; }
                     extinfLine += ` ${key}=${value}`;
                }

                 m3uContent += `${extinfLine},${channel.name || ''}\n`;

                for (const key in channel.kodiProps) { if (channel.kodiProps[key]) m3uContent += `#KODIPROP:${key}=${channel.kodiProps[key]}\n`; }
                 for (const key in channel.vlcOptions) { if (channel.vlcOptions[key]) m3uContent += `#EXTVLCOPT:${key}=${channel.vlcOptions[key]}\n`; }


                 m3uContent += `${channel.url || ''}\n`;
             });

            try {
                 const blob = new Blob([m3uContent], { type: 'application/vnd.apple.mpegurl;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 a.href = url;
                const safeFileNameBase = (currentFileName || 'edited_list.m3u').replace(/\.[^/.]+$/, "");
                 const extension = (currentFileName || '.m3u').split('.').pop()?.toLowerCase() || 'm3u';
                 const safeExtension = ['m3u', 'm3u8'].includes(extension) ? extension : 'm3u';
                 const safeFileName = `${safeFileNameBase}_edited.${safeExtension}`.replace(/[^a-z0-9_.\-]/gi, '_').replace(/_{2,}/g, '_');
                 a.download = safeFileName;
                 document.body.appendChild(a);
                 a.click();
                document.body.removeChild(a);
                 URL.revokeObjectURL(url);
                showToast(`Archivo guardado correctamente como ${safeFileName}`, 'success');
             } catch (error) {
                 showToast('Error al generar o descargar el archivo.', 'error');
                 console.error("Save error:", error);
            } finally {
                setLoading(false);
            }
         }

        function renderTable() {
            const searchTerm = searchInput.value.toLowerCase().trim();
            const fragment = document.createDocumentFragment();
             let visibleCount = 0;

            const filteredChannels = channels.filter(channel => {
                if (!channel) return false;
                 if (showOnlyFavorites && !channel.favorite) return false;
                if (currentGroupFilter && (channel['group-title'] || '') !== currentGroupFilter) return false;
                if (searchTerm) {
                    const nameMatch = channel.name?.toLowerCase().includes(searchTerm);
                    const urlMatch = channel.url?.toLowerCase().includes(searchTerm);
                    const groupMatch = channel['group-title']?.toLowerCase().includes(searchTerm);
                     const tvgIdMatch = channel['tvg-id']?.toLowerCase().includes(searchTerm);
                    if (!nameMatch && !urlMatch && !groupMatch && !tvgIdMatch) return false;
                 }
                return true;
             });


            const sortedChannels = [...filteredChannels];
            if (currentSort.column) {
                 sortedChannels.sort((a, b) => {
                    let valA, valB;
                    if (currentSort.column === 'name' || currentSort.column === 'group-title' || currentSort.column === 'tvg-id') {
                         valA = (a[currentSort.column] || '').toLowerCase();
                         valB = (b[currentSort.column] || '').toLowerCase();
                    } else if (currentSort.column === 'ch-number') {
                        valA = parseInt(a['ch-number']) || -Infinity;
                        valB = parseInt(b['ch-number']) || -Infinity;
                         if (a['ch-number'] === '' || a['ch-number'] === '-1' || isNaN(valA)) valA = -Infinity;
                        if (b['ch-number'] === '' || b['ch-number'] === '-1' || isNaN(valB)) valB = -Infinity;
                    } else if (currentSort.column === 'active') {
                         const statusOrder = { true: 4, checking: 3, null: 2, false: 1 };
                         valA = statusOrder[a.active] || 2;
                         valB = statusOrder[b.active] || 2;
                    } else {
                         valA = (a[currentSort.column] || '').toLowerCase();
                        valB = (b[currentSort.column] || '').toLowerCase();
                     }
                     let comparison = 0;
                     if (valA < valB) comparison = -1;
                     else if (valA > valB) comparison = 1;
                    return comparison * (currentSort.direction === 'asc' ? 1 : -1);
                 });
            } else {
                 sortedChannels.sort((a, b) => {
                    const groupA = a['group-title'] || ''; const groupB = b['group-title'] || '';
                    const indexA = groupOrder.indexOf(groupA); const indexB = groupOrder.indexOf(groupB);
                    const effectiveIndexA = indexA === -1 ? Infinity : indexA;
                    const effectiveIndexB = indexB === -1 ? Infinity : indexB;
                    if (effectiveIndexA !== effectiveIndexB) return effectiveIndexA - effectiveIndexB;
                     return a.originalIndex - b.originalIndex;
                 });
            }

             const channelsByGroup = sortedChannels.reduce((acc, channel) => {
                 const groupKey = channel['group-title'] || '';
                 if (!acc[groupKey]) acc[groupKey] = [];
                acc[groupKey].push(channel);
                 return acc;
             }, {});


            groupOrder.forEach(groupKey => {
                 if (channelsByGroup[groupKey]?.length > 0) {
                    const groupChannels = channelsByGroup[groupKey];
                     const isCollapsed = collapsedGroups.has(groupKey);
                    fragment.appendChild(createGroupHeaderRow(groupKey, groupChannels.length, isCollapsed));
                    groupChannels.forEach((channel) => {
                         fragment.appendChild(createRow(channel, isCollapsed));
                         if (!isCollapsed) visibleCount++;
                    });
                }
             });
            Object.keys(channelsByGroup).forEach(groupKey => {
                 if (!groupOrder.includes(groupKey)) {
                     const groupChannels = channelsByGroup[groupKey];
                    const isCollapsed = collapsedGroups.has(groupKey);
                     fragment.appendChild(createGroupHeaderRow(groupKey, groupChannels.length, isCollapsed));
                     groupChannels.forEach((channel) => {
                        fragment.appendChild(createRow(channel, isCollapsed));
                        if (!isCollapsed) visibleCount++;
                    });
                }
             });

             tableBody.innerHTML = '';
            if (channels.length > 0 && fragment.children.length === 0 && !searchTerm && !currentGroupFilter && !showOnlyFavorites) {
                 tableBody.innerHTML = `<tr><td colspan="8" style="text-align:center; padding: 40px 20px; color: var(--text-light);">Todos los grupos están colapsados o vacíos.</td></tr>`;
            } else if (channels.length > 0 && fragment.children.length === 0) {
                 tableBody.innerHTML = `<tr><td colspan="8" style="text-align:center; padding: 40px 20px; color: var(--text-light);">No se encontraron canales que coincidan con los filtros.</td></tr>`;
             } else if (channels.length === 0) {
                 tableBody.innerHTML = `<tr><td colspan="8" style="text-align:center; padding: 40px 20px; color: var(--text-light);">Carga un archivo M3U o añade un canal nuevo.</td></tr>`;
             } else {
                 tableBody.appendChild(fragment);
             }


             updateSelectAllCheckboxState();
             updateSortIcons();
        }

        function createGroupHeaderRow(group, count, isCollapsed) {
            const headerRow = document.createElement('tr');
             headerRow.className = `group-header-row ${isCollapsed ? 'collapsed' : ''}`;
            headerRow.dataset.group = group;
            const displayName = group === '' ? '(Sin Grupo)' : escapeHtml(group);
             const toggleIconClass = isCollapsed ? 'fa-chevron-right' : 'fa-chevron-down';
            headerRow.innerHTML = `<td colspan="8"><span class="group-toggle-icon"><i class="fas ${toggleIconClass}"></i></span> ${displayName} <span class="group-channel-count">(${count})</span></td>`;
             return headerRow;
        }

         function toggleGroupCollapse(group) {
            const headerRow = tableBody.querySelector(`.group-header-row[data-group="${group}"]`);
            const channelRows = tableBody.querySelectorAll(`.channel-row[data-group-parent="${group}"]`);
            const icon = headerRow?.querySelector('.group-toggle-icon i');
             if (!headerRow || !icon) return;

            if (collapsedGroups.has(group)) {
                collapsedGroups.delete(group);
                 headerRow.classList.remove('collapsed');
                icon.classList.replace('fa-chevron-right', 'fa-chevron-down');
                 channelRows.forEach(row => row.classList.remove('hidden'));
            } else {
                collapsedGroups.add(group);
                headerRow.classList.add('collapsed');
                 icon.classList.replace('fa-chevron-down', 'fa-chevron-right');
                 channelRows.forEach(row => row.classList.add('hidden'));
            }

            updateSelectAllCheckboxState();
            triggerLocalStorageSave();
        }


         function createRow(channel, isGroupCollapsed) {
             const row = document.createElement('tr');
             row.dataset.index = channel.originalIndex;
            row.dataset.groupParent = channel['group-title'] || '';
             row.classList.add('channel-row');
            row.classList.toggle('selected-row', channel.originalIndex === selectedChannelOriginalIndex);
             row.classList.toggle('hidden', isGroupCollapsed);

             let statusIcon = 'fa-question-circle';
             let statusClass = 'status-unknown';
             let statusText = 'N/D';
             let statusTitle = 'Desconocido';
             if (channel.active === true) { statusIcon = 'fa-check-circle'; statusClass = 'status-active'; statusText = 'Activo'; statusTitle = 'Activo'; }
             else if (channel.active === false) { statusIcon = 'fa-times-circle'; statusClass = 'status-inactive'; statusText = 'Inactivo'; statusTitle = 'Inactivo'; }
             else if (channel.active === 'checking') { statusIcon = 'fa-spinner fa-spin'; statusClass = 'status-checking'; statusText = 'Check...'; statusTitle = 'Validando...'; }
             const statusHtml = `<span class="status-badge ${statusClass}" title="${statusTitle}"><i class="fas ${statusIcon}"></i> ${statusText}</span>`;

            const logoHtml = channel['tvg-logo']
                ? `<img src="${escapeHtml(channel['tvg-logo'])}" class="logo-preview" loading="lazy" onerror="handleImageError(this)">`
                : `<span>-</span>`;

             const nameHtml = `${channel.favorite ? '<i class="fas fa-star favorite-icon" title="Favorito" style="font-size: 0.8em; margin-right: 4px; color: orange;"></i> ' : ''}${escapeHtml(channel.name || '')}`;

             row.innerHTML = `
                <td class="checkbox-cell"><input type="checkbox" class="row-checkbox" data-index="${channel.originalIndex}" ${selectedRowIndices.has(channel.originalIndex) ? 'checked' : ''}></td>
                 <td class="handle-cell"><i class="fas fa-grip-lines drag-handle"></i></td>
                 <td class="logo-cell">${logoHtml}</td>
                <td class="name-cell" title="${escapeHtml(channel.name || '')}">${nameHtml}</td>
                <td class="url-cell" title="${escapeHtml(channel.url || '')}">${escapeHtml(channel.url || '')}</td>
                <td class="epg-cell" title="${escapeHtml(channel['tvg-id'] || '')}">${escapeHtml(channel['tvg-id'] || '-')}</td>
                 <td class="ch-num-cell">${escapeHtml(channel['ch-number'] || '-')}</td>
                 <td class="status-cell">${statusHtml}</td>
                 `;
             return row;
         }


        function updateSingleRow(originalIndex) {
             const channel = channels.find(ch => ch && ch.originalIndex === originalIndex);
             const row = tableBody.querySelector(`tr.channel-row[data-index="${originalIndex}"]`);
             if (!row || !channel) return;

             const isCollapsed = collapsedGroups.has(channel['group-title'] || '');
             const newRow = createRow(channel, isCollapsed);

             row.replaceWith(newRow);

             if (originalIndex === selectedChannelOriginalIndex) {
                 newRow.classList.add('selected-row');
             }
        }


        function updateGroupOrder() {
            const currentGroups = [...new Set(channels.map(ch => ch['group-title'] || ''))];
             const newGroupOrder = groupOrder.filter(group => currentGroups.includes(group));
            currentGroups.forEach(group => { if (!newGroupOrder.includes(group)) newGroupOrder.push(group); });
             groupOrder = newGroupOrder;
        }
        function updateGroupOrderIfNeeded(oldGroup, newGroup) {
            let orderChanged = false;
             if (newGroup !== null && newGroup !== undefined && !groupOrder.includes(newGroup) && channels.some(ch => (ch['group-title'] || '') === newGroup)) {
                 groupOrder.push(newGroup);
                 orderChanged = true;
             }
             if (oldGroup !== null && oldGroup !== undefined && oldGroup !== newGroup && !channels.some(ch => (ch['group-title'] || '') === oldGroup)) {
                groupOrder = groupOrder.filter(g => g !== oldGroup);
                orderChanged = true;
             }
             if (orderChanged) { updateGroupFilter(); updateGroupSuggestions(); }
        }
        function updateGroupOrderAfterRename(oldGroup, newGroup) {
             const index = groupOrder.indexOf(oldGroup);
            if (index !== -1) {
                 if (groupOrder.includes(newGroup)) { groupOrder.splice(index, 1); }
                 else { groupOrder[index] = newGroup; }
             } else if (!groupOrder.includes(newGroup)) {
                 groupOrder.push(newGroup);
             }
             groupOrder = groupOrder.filter((value, idx, self) => self.indexOf(value) === idx);
         }
        function updateGroupFilter() {
             const currentFilterValue = groupFilterSelect.value;
            groupFilterSelect.innerHTML = '<option value="">Todos los Grupos</option>';
            groupOrder.forEach(group => {
                 const displayName = group === '' ? '(Sin Grupo)' : escapeHtml(group);
                groupFilterSelect.insertAdjacentHTML('beforeend', `<option value="${escapeHtml(group)}">${displayName}</option>`);
            });
            if (groupOrder.includes(currentFilterValue) || currentFilterValue === '') groupFilterSelect.value = currentFilterValue;
             else { groupFilterSelect.value = ''; currentGroupFilter = ''; }
         }
        function handleSort(column) {
             if (!column) return;
            if (currentSort.column === column) {
                 currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                 currentSort.column = column; currentSort.direction = 'asc';
             }
             renderTable();
            triggerLocalStorageSave();
         }
        function toggleFavoritesFilter() {
            showOnlyFavorites = !showOnlyFavorites;
             updateToggleFavoritesButton();
             renderTable();
            triggerLocalStorageSave();
        }
         function updateToggleFavoritesButton() {
             const icon = toggleFavoritesBtn.querySelector('i');
             toggleFavoritesBtn.title = showOnlyFavorites ? 'Mostrar Todos los Canales' : 'Mostrar Solo Favoritos';
             if (showOnlyFavorites) { icon.classList.replace('far', 'fas'); toggleFavoritesBtn.classList.add('active');}
             else { icon.classList.replace('fas', 'far'); toggleFavoritesBtn.classList.remove('active'); }
         }
         function updateSortIcons() {
            document.querySelectorAll('#channels-table th.sortable i.fa-sort-up, #channels-table th.sortable i.fa-sort-down').forEach(icon => {
                 icon.className = 'fas fa-sort';
                 icon.style.color = 'var(--text-light)';
            });
            if (currentSort.column) {
                 const currentTh = document.querySelector(`#channels-table th[data-sort="${currentSort.column}"]`);
                 if (currentTh) {
                    const icon = currentTh.querySelector('i');
                     if(icon) {
                         icon.className = `fas fa-sort-${currentSort.direction === 'asc' ? 'up' : 'down'}`;
                         icon.style.color = 'var(--text-dark)';
                    }
                 }
             }
         }

        async function validateSingleUrl(originalIndex, updateRowUI = true) {
            const channelIndex = channels.findIndex(ch => ch && ch.originalIndex === originalIndex);
            if (channelIndex === -1) return false;
             const channel = channels[channelIndex];
            const url = channel.url;
             if (!url || !(url.startsWith('http:') || url.startsWith('https:'))) { channel.active = false; if(updateRowUI) updateSingleRow(originalIndex); return false; }
            channel.active = 'checking'; if(updateRowUI) updateSingleRow(originalIndex);
            let isActive = false; try { await fetch(url, { method: 'HEAD', mode: 'no-cors', signal: AbortSignal.timeout(5000) }); isActive = true; } catch (error) { isActive = false; }
            channel.active = isActive; if(updateRowUI) updateSingleRow(originalIndex); return channel.active === true;
        }
        async function validateAllUrls() {
            if (validationInProgress || channels.length === 0) { if(validationInProgress) showToast('Validación ya en progreso.', 'warning'); else showToast('No hay canales para validar.', 'info'); return; }
             validationInProgress = true; setLoading(true, 'Validando URLs (0%)...'); showToast(`Iniciando validación para ${channels.length} URLs...`, 'info', 4000);
             let processedCount = 0, validCount = 0, invalidCount = 0; const totalChannels = channels.length; const chunkSize = 10; let lastRenderTime = Date.now();
             for (let i = 0; i < totalChannels; i += chunkSize) {
                 const chunkPromises = [];
                for (let j = 0; j < chunkSize && i + j < totalChannels; j++) { const currentChannel = channels[i+j]; if (currentChannel && currentChannel.originalIndex !== undefined) chunkPromises.push(validateSingleUrl(currentChannel.originalIndex, false).catch(() => false)); }
                 await Promise.allSettled(chunkPromises);
                processedCount = Math.min(i + chunkSize, totalChannels); const percentage = Math.round((processedCount / totalChannels) * 100);
                 if (Date.now() - lastRenderTime > 500 || percentage === 100) { setLoading(true, `Validando URLs (${percentage}%)... ${processedCount}/${totalChannels}`); renderTable(); lastRenderTime = Date.now(); }
            }
             validCount = channels.filter(ch => ch && ch.active === true).length; invalidCount = channels.filter(ch => ch && ch.active === false).length; setLoading(false); validationInProgress = false; showToast(`Validación completa. Activas: ${validCount}, Inactivas/No HTTP: ${invalidCount}.`, 'success'); renderTable(); triggerLocalStorageSave();
        }
         function findAndShowDuplicatesModal() {
             if (channels.length < 2) { showToast('Se necesitan al menos 2 canales para buscar duplicados.', 'info'); return; } setLoading(true, 'Buscando URLs duplicadas...'); const urlMap = new Map(); channels.forEach((ch) => { if (!ch || !ch.url) return; const url = ch.url; if (!urlMap.has(url)) urlMap.set(url, []); urlMap.get(url).push(ch.originalIndex); }); const duplicatesFound = []; urlMap.forEach((indices, url) => { if (indices.length > 1) duplicatesFound.push({ url, indices }); }); const listDiv = document.getElementById('duplicates-list'); listDiv.innerHTML = ''; if (duplicatesFound.length === 0) { setLoading(false); showToast('¡Buenas noticias! No se encontraron URLs duplicadas.', 'success'); return; } duplicatesFound.sort((a, b) => b.indices.length - a.indices.length); duplicatesFound.forEach(({ url, indices }) => { const setDiv = document.createElement('div'); setDiv.className = 'duplicate-set'; setDiv.dataset.url = url; setDiv.innerHTML = `<p><strong>URL Duplicada:</strong> <code>${escapeHtml(url)}</code> (${indices.length} canales)</p><ul></ul><button class="btn btn-sm btn-danger delete-duplicates-for-url" data-url="${escapeHtml(url)}" data-indices='${JSON.stringify(indices)}'><i class="fas fa-trash"></i> Guardar Primero, Borrar Resto</button>`; const ul = setDiv.querySelector('ul'); indices.forEach(idx => { const ch = channels.find(c => c.originalIndex === idx); if (ch) ul.innerHTML += `<li data-index="${idx}">#${idx + 1}: ${escapeHtml(ch.name || 'N/A')} (${escapeHtml(ch['group-title'] || 'S/G')})</li>`; }); listDiv.appendChild(setDiv); }); setLoading(false); openModal(duplicatesModal); duplicatesModified = false;
        }
         async function handleDeleteDuplicatesForUrl(e) {
            const button = e.target.closest('.delete-duplicates-for-url'); if (!button) return; const url = button.dataset.url; const indicesStr = button.dataset.indices; if (!url || !indicesStr) return; let originalIndices; try { originalIndices = JSON.parse(indicesStr); } catch (err) { showToast('Error procesando índices de duplicados.', 'error'); return; } if (!Array.isArray(originalIndices) || originalIndices.length < 2) return; originalIndices.sort((a, b) => a - b); const indexToKeep = originalIndices[0]; const indicesToDelete = originalIndices.slice(1); const userConfirmed = await showConfirmationModal(`Eliminar ${indicesToDelete.length} duplicados para la URL <br><code>${escapeHtml(url)}</code>?<br>Se conservará el canal #${indexToKeep + 1}.`, 'Confirmar Eliminación de Duplicados', 'Sí, Eliminar Duplicados', 'btn-danger'); if (userConfirmed) { let deletedCount = 0; channels = channels.filter(ch => { const shouldDelete = indicesToDelete.includes(ch.originalIndex); if (shouldDelete) { deletedCount++; selectedRowIndices.delete(ch.originalIndex); if (ch.originalIndex === selectedChannelOriginalIndex) showEditorPlaceholder(); return false; } return true; }); if (deletedCount > 0) { channels.forEach((ch, idx) => ch.originalIndex = idx); showToast(`${deletedCount} canales duplicados eliminados.`, 'success'); button.closest('.duplicate-set').remove(); duplicatesModified = true; triggerLocalStorageSave(); renderTable(); updateSelectAllCheckboxState(); if (document.getElementById('duplicates-list').children.length === 0) closeModal(duplicatesModal); } else { showToast('No se encontraron duplicados para eliminar.', 'warning'); button.closest('.duplicate-set').remove(); } }
        }
         function handleCompareFileSelect(e) {
             const file = e.target.files[0]; if (!file || channels.length === 0) { if(!file) return; showToast('Carga primero una lista principal para comparar.', 'warning'); compareFileInput.value = ''; return; } comparisonFileName = file.name; setLoading(true, `Leyendo archivo de comparación...`); const reader = new FileReader(); reader.onload = (ev) => { try { comparisonChannels = parseM3U(ev.target.result); showToast(`Archivo de comparación "${escapeHtml(comparisonFileName)}" cargado (${comparisonChannels.length} canales). Comparando...`, 'info', 3000); compareLists(); } catch (error) { showToast(`Error procesando archivo de comparación: ${escapeHtml(error.message)}`, 'error', 5000); comparisonChannels = []; comparisonFileName = ''; } finally { setLoading(false); compareFileInput.value = ''; } }; reader.onerror = () => { showToast('Error leyendo archivo de comparación.', 'error'); setLoading(false); comparisonChannels = []; comparisonFileName = ''; compareFileInput.value = ''; }; reader.readAsText(file);
        }
         function compareLists() {
             setLoading(true, 'Comparando listas...'); const listAName = currentFileName || 'Lista Actual'; const listBName = comparisonFileName || 'Lista de Comparación'; document.getElementById('compare-list-a-name').textContent = listAName; document.getElementById('compare-list-b-name').textContent = listBName; document.querySelectorAll('.compare-list-a-name-dynamic').forEach(el => el.textContent = listAName); document.querySelectorAll('.compare-list-b-name-dynamic').forEach(el => el.textContent = listBName); const mapA = new Map(channels.map(ch => [ch.url, { ...ch }])); const mapB = new Map(comparisonChannels.map((ch, idx) => [ch.url, { ...ch, listIndex: idx }])); const onlyInA = [], onlyInB = [], common = []; mapA.forEach((chA, url) => { if (mapB.has(url)) { common.push({ channelA: chA, channelB: mapB.get(url) }); mapB.delete(url); } else { onlyInA.push(chA); } }); mapB.forEach(chB => onlyInB.push(chB)); renderComparisonResults(onlyInA, common, onlyInB); openModal(compareModal); setLoading(false);
         }
        function renderComparisonResults(onlyInA, common, onlyInB) {
             const listAEl = document.getElementById('compare-list-a'); const commonEl = document.getElementById('compare-list-common'); const listBEl = document.getElementById('compare-list-b'); listAEl.innerHTML = ''; commonEl.innerHTML = ''; listBEl.innerHTML = ''; document.getElementById('count-only-a').textContent = onlyInA.length; document.getElementById('count-common').textContent = common.length; document.getElementById('count-only-b').textContent = onlyInB.length; onlyInA.forEach(ch => listAEl.innerHTML += `<li title="URL: ${escapeHtml(ch.url)}">#${ch.originalIndex + 1}: ${escapeHtml(ch.name || '')} (${escapeHtml(ch['group-title'] || 'S/G')})</li>`); common.forEach(pair => { const nameA = pair.channelA.name || '', nameB = pair.channelB.name || '', groupA = pair.channelA['group-title'] || '', groupB = pair.channelB['group-title'] || ''; let diff = []; let nameD = escapeHtml(nameA), groupD = escapeHtml(groupA || '(S/G)'); if (nameA !== nameB) { nameD = `<span class="compare-diff" title="Nombre en B: ${escapeHtml(nameB)}">${escapeHtml(nameA)}</span>`; diff.push("Nombre"); } if (groupA !== groupB) { groupD = `<span class="compare-diff" title="Grupo en B: ${escapeHtml(groupB || '(S/G)')}">${escapeHtml(groupA || '(S/G)')}</span>`; diff.push("Grupo"); } const title = `URL: ${escapeHtml(pair.channelA.url)}${diff.length ? ' | Diferencias: ' + diff.join(', ') : ' | Sin diferencias detectadas'}`; commonEl.innerHTML += `<li title="${title}">#${pair.channelA.originalIndex + 1}: ${nameD} (${groupD})</li>`; }); onlyInB.forEach(ch => { try { const data = { ...ch }; delete data.active; delete data.listIndex; listBEl.innerHTML += `<li data-channel-data='${escapeHtml(JSON.stringify(data))}' title="URL: ${escapeHtml(ch.url)}">${escapeHtml(ch.name || '')} (${escapeHtml(ch['group-title'] || 'S/G')})</li>`; } catch (e) { console.error("Error stringifying compare B channel", e); } }); document.getElementById('copy-missing-to-a-btn').disabled = onlyInB.length === 0; document.getElementById('merge-lists-btn').disabled = onlyInB.length === 0;
        }
         function copyMissingChannelsToA() {
             const channelsToAdd = []; const existingUrls = new Set(channels.map(ch => ch.url)); document.querySelectorAll('#compare-list-b li').forEach(li => { if (li.dataset.channelData) { try { const chData = JSON.parse(li.dataset.channelData); if (chData.url && !existingUrls.has(chData.url)) { const newCh = { ...chData, active: null, originalIndex: -1 }; channelsToAdd.push(newCh); existingUrls.add(chData.url); } } catch (e) { console.error("Error parsing compare B data", e); } } }); if (channelsToAdd.length > 0) { channels.push(...channelsToAdd); channels.forEach((ch, idx) => ch.originalIndex = idx); showToast(`Se añadieron ${channelsToAdd.length} nuevos canales desde la lista de comparación.`, 'success'); updateGroupOrder(); renderTable(); updateGroupFilter(); if (groupsManagementModal.style.display === 'flex') renderGroupsInModal(); closeModal(compareModal); triggerLocalStorageSave(); } else { showToast('No se encontraron nuevos canales para añadir.', 'info'); }
        }
         async function mergeLists() {
            if (!comparisonChannels || comparisonChannels.length === 0) { showToast('No hay datos de comparación cargados.', 'warning'); return; } const channelsToAdd = []; const existingUrls = new Set(channels.map(ch => ch.url)); comparisonChannels.forEach(chB => { if (chB && chB.url && !existingUrls.has(chB.url)) { const newCh = { ...chB, active: null, originalIndex: -1 }; channelsToAdd.push(newCh); existingUrls.add(chB.url); } }); if (channelsToAdd.length === 0) { showToast('No se encontraron nuevos canales para añadir en la lista de comparación.', 'info'); closeModal(compareModal); return; } const userConfirmed = await showConfirmationModal(`Se encontraron ${channelsToAdd.length} canales en la lista de comparación que no existen en la lista actual (por URL). ¿Deseas añadirlos al final?`, 'Confirmar Fusión', `Añadir ${channelsToAdd.length} Canales`, 'btn-success'); if (userConfirmed) { setLoading(true, 'Fusionando listas...'); channels.push(...channelsToAdd); channels.forEach((ch, idx) => ch.originalIndex = idx); updateGroupOrder(); renderTable(); updateGroupFilter(); if (groupsManagementModal.style.display === 'flex') renderGroupsInModal(); triggerLocalStorageSave(); showToast(`Fusión completada: Se añadieron ${channelsToAdd.length} canales nuevos.`, 'success'); closeModal(compareModal); setLoading(false); }
        }
         async function handleClearStorage() {
             const userConfirmed = await showConfirmationModal( '¿Borrar todos los datos de sesión guardados (lista, ajustes) de este navegador? Esta acción no se puede deshacer.', 'Confirmar Limpiar Sesión', 'Sí, Limpiar Sesión', 'btn-danger');
            if (userConfirmed) {
                 clearLocalStorage();
                showToast('Sesión local borrada.', 'info');
                channels = []; groupOrder = []; selectedRowIndices.clear(); selectedChannelOriginalIndex = null;
                 currentFileName = ''; currentSort = { column: null, direction: 'asc' }; currentGroupFilter = '';
                 showOnlyFavorites = false; searchInput.value = ''; collapsedGroups.clear();
                fileNameDisplay.textContent = 'Ningún archivo cargado'; fileNameDisplay.classList.remove('loaded');
                 showEditorPlaceholder(); renderTable(); updateGroupFilter(); updateToggleFavoritesButton();
            }
        }
         async function handleNewList() {
            let doCreateNew = true;
            if (channels.length > 0) {
                 doCreateNew = await showConfirmationModal('¿Crear una nueva lista vacía? Los cambios no guardados en la lista actual se perderán.', 'Confirmar Nueva Lista', 'Sí, Crear Nueva', 'btn-warning');
            }
            if (doCreateNew) {
                 channels = []; groupOrder = []; selectedRowIndices.clear(); selectedChannelOriginalIndex = null;
                 currentFileName = ''; currentSort = { column: null, direction: 'asc' }; currentGroupFilter = '';
                 showOnlyFavorites = false; searchInput.value = ''; collapsedGroups.clear();
                fileNameDisplay.textContent = 'Nueva Lista Sin Título'; fileNameDisplay.classList.remove('loaded');
                showEditorPlaceholder(); renderTable(); updateGroupFilter(); updateToggleFavoritesButton();
                clearLocalStorage(); showToast('Nueva lista vacía creada.', 'info');
            }
        }
        function saveToLocalStorage() {
            if (validationInProgress || loadingOverlay.style.display === 'flex') return;
             try {
                const stateToSave = {
                    channels: channels, groupOrder: groupOrder, collapsedGroups: Array.from(collapsedGroups),
                     currentFileName: currentFileName, currentSort: currentSort, currentGroupFilter: currentGroupFilter,
                    showOnlyFavorites: showOnlyFavorites, selectedChannelOriginalIndex: selectedChannelOriginalIndex,
                    isSidebarExpanded: document.body.classList.contains('sidebar-expanded'),
                    timestamp: Date.now()
                };
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(stateToSave));
             } catch (error) {
                 showToast(`Error guardando sesión: ${error.message}`, 'error');
                console.error("Local Storage save error:", error);
             }
        }
         async function loadFromLocalStorage() {
            const savedState = localStorage.getItem(LOCAL_STORAGE_KEY);
             if (!savedState) return;
            try {
                 const parsedState = JSON.parse(savedState);
                 if (!parsedState.channels || !Array.isArray(parsedState.channels) || !parsedState.timestamp) {
                    clearLocalStorage(); return;
                 }
                const savedDate = new Date(parsedState.timestamp);
                 const userConfirmed = await showConfirmationModal(`Se encontró una sesión guardada de ${savedDate.toLocaleString()}. ¿Deseas restaurarla?`, 'Restaurar Sesión Anterior', 'Sí, Restaurar', 'btn-success');
                 if (userConfirmed) {
                    setLoading(true, 'Restaurando sesión...');
                     channels = parsedState.channels || [];
                     channels.forEach((ch, idx) => {
                        ch.originalIndex = idx;
                        ch.active = null;
                         ch.attributes = ch.attributes || {};
                        ch.kodiProps = ch.kodiProps || {};
                        ch.vlcOptions = ch.vlcOptions || {};
                         ch.favorite = ch.favorite || false;
                    });
                    groupOrder = parsedState.groupOrder || [];
                    collapsedGroups = new Set(parsedState.collapsedGroups || []);
                    currentFileName = parsedState.currentFileName || 'Sesión Restaurada';
                     currentSort = parsedState.currentSort || { column: null, direction: 'asc' };
                    currentGroupFilter = parsedState.currentGroupFilter || '';
                     showOnlyFavorites = parsedState.showOnlyFavorites || false;
                     selectedChannelOriginalIndex = parsedState.selectedChannelOriginalIndex !== undefined ? parsedState.selectedChannelOriginalIndex : null;
                     setSidebarState(parsedState.isSidebarExpanded || false);


                    fileNameDisplay.textContent = escapeHtml(currentFileName);
                     if(currentFileName) fileNameDisplay.classList.add('loaded'); else fileNameDisplay.classList.remove('loaded');
                     groupFilterSelect.value = currentGroupFilter;
                     searchInput.value = '';
                    updateToggleFavoritesButton();


                     updateGroupOrder();
                    clearMultiSelection(false);
                    renderTable();
                    updateGroupFilter();
                    updateGroupSuggestions();


                     if (selectedChannelOriginalIndex !== null && channels.some(ch=> ch.originalIndex === selectedChannelOriginalIndex)) {
                         displayChannelInEditor(selectedChannelOriginalIndex);
                    } else {
                        showEditorPlaceholder();
                        selectedChannelOriginalIndex = null;
                     }

                    showToast('Sesión anterior restaurada.', 'success');
                    setLoading(false);
                 } else {
                     clearLocalStorage();
                     showToast('Sesión anterior descartada.', 'info');
                 }
            } catch (error) {
                showToast('Error restaurando sesión. Limpiando datos guardados.', 'error');
                 console.error("Error loading from Local Storage:", error);
                clearLocalStorage();
                setLoading(false);
             }
        }
         function clearLocalStorage() {
             localStorage.removeItem(LOCAL_STORAGE_KEY);
             localStorage.removeItem(SIDEBAR_STATE_KEY);
         }

        function toggleSidebar() {
             setSidebarState(!document.body.classList.contains('sidebar-expanded'));
             triggerLocalStorageSave();
        }
        function setSidebarState(expanded) {
            if(expanded) {
                document.body.classList.add('sidebar-expanded');
                sidebarToggleBtn.title = "Colapsar Menú";
             } else {
                document.body.classList.remove('sidebar-expanded');
                sidebarToggleBtn.title = "Expandir Menú";
            }
             isSidebarExpanded = expanded;
             localStorage.setItem(SIDEBAR_STATE_KEY, expanded ? 'true' : 'false');
         }
        function loadSidebarState() {
            const savedState = localStorage.getItem(SIDEBAR_STATE_KEY);
             setSidebarState(savedState === 'true');
         }


        document.addEventListener('DOMContentLoaded', async () => {
             loadSidebarState();
             initEventListeners();
             initSortable();
             showEditorPlaceholder();
             updateGroupFilter();
             updateToggleFavoritesButton();

             await loadFromLocalStorage();

             if (channels.length === 0 && !localStorage.getItem(LOCAL_STORAGE_KEY)) {
                 renderTable();
             }
         });

    </script>

</body>
</html>
